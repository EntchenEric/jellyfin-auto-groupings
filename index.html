<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jellyfin Groupings | Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Outfit:wght@300;400;500;600;700;800;900&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-color: #0d0d12;
            --surface-color: #1a1a24;
            --accent-color: #6366f1;
            --accent-hover: #4f46e5;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
            --success-color: #10b981;
            --error-color: #ef4444;
            --radius-lg: 16px;
            --radius-md: 12px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --container-width: 1200px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
        }

        .background-blob {
            position: fixed;
            width: 600px;
            height: 600px;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.15) 0%, rgba(0, 0, 0, 0) 70%);
            border-radius: 50%;
            z-index: -1;
            filter: blur(80px);
            animation: move-blob 20s infinite alternate;
        }

        @keyframes move-blob {
            0% {
                transform: translate(-20%, -20%) scale(1);
            }

            100% {
                transform: translate(20%, 20%) scale(1.2);
            }
        }

        .container {
            width: 100%;
            max-width: var(--container-width);
            padding: 2rem;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
        }

        h1 {
            font-family: 'Outfit', sans-serif;
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
            font-weight: 300;
        }

        .card {
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-lg);
            padding: 2.5rem;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
            align-items: start;
        }

        @media (min-width: 1024px) {
            .main-grid {
                grid-template-columns: 400px 1fr;
            }
        }

        h2,
        h3 {
            font-family: 'Outfit', sans-serif;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        input[type="url"],
        input[type="password"],
        input[type="text"] {
            width: 100%;
            padding: 0.8rem 1rem;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 1rem;
            transition: var(--transition);
        }

        input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
            background: rgba(0, 0, 0, 0.3);
        }

        button {
            width: 100%;
            padding: 1rem;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            margin-top: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }

        button:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .secondary-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            border-radius: var(--radius-md);
        }

        .secondary-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--accent-color);
            color: var(--text-primary);
        }

        .group-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: 1rem;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--transition);
        }

        .group-card:hover {
            border-color: var(--accent-color);
            background: rgba(255, 255, 255, 0.08);
        }

        .group-info h4 {
            font-size: 1.1rem;
            margin-bottom: 0.2rem;
        }

        .group-meta {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .delete-btn {
            background: transparent;
            color: var(--error-color);
            border: 1px solid var(--error-color);
            padding: 0.5rem 0.8rem;
            font-size: 0.8rem;
            width: auto;
            margin: 0;
        }

        .delete-btn:hover {
            background: var(--error-color);
            color: white;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
        }

        .status-msg {
            margin-top: 1.5rem;
            text-align: center;
            font-weight: 500;
            padding: 0.8rem;
            border-radius: var(--radius-md);
            display: none;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .status-msg.success {
            display: block;
            background: rgba(16, 185, 129, 0.1);
            color: var(--success-color);
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .status-msg.error {
            display: block;
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-color);
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .btn-loading .loading-spinner {
            display: block;
        }

        .btn-loading .btn-text {
            display: none;
        }

        .footer {
            margin-top: 2rem;
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        select:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .modal-item {
            padding: 0.8rem;
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .modal-item:last-child {
            border-bottom: none;
        }

        .locked-section {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(0.2);
            position: relative;
        }

        .locked-overlay-text {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-5deg);
            background: var(--error-color);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.9rem;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
            pointer-events: none;
            text-transform: uppercase;
        }

        .locked-section .locked-overlay-text {
            display: block;
        }

        .connection-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
            background: #444;
        }

        .connection-dot.online {
            background: var(--success-color);
            box-shadow: 0 0 8px var(--success-color);
        }

        .connection-dot.offline {
            background: var(--error-color);
            box-shadow: 0 0 8px var(--error-color);
        }

        /* ‚îÄ‚îÄ Folder Picker ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        .picker-row {
            display: flex;
            gap: 0.5rem;
            align-items: stretch;
        }

        .picker-row input {
            flex: 1;
            min-width: 0;
        }

        .browse-btn {
            flex-shrink: 0;
            width: auto;
            padding: 0 1rem;
            margin: 0;
            font-size: 0.85rem;
            border-radius: var(--radius-md);
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
        }

        .browse-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: var(--accent-color);
            color: var(--text-primary);
            transform: none;
            box-shadow: none;
        }

        .browse-btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        /* Picker modal */
        #path-picker-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
        }

        .picker-box {
            background: var(--surface-color);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-lg);
            width: min(600px, 95vw);
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 24px 60px rgba(0, 0, 0, 0.6);
            overflow: hidden;
        }

        .picker-header {
            padding: 1.2rem 1.5rem 0.8rem;
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }

        .picker-title {
            font-family: 'Outfit', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .picker-breadcrumb {
            font-size: 0.78rem;
            color: var(--text-secondary);
            word-break: break-all;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.2);
            padding: 0.35rem 0.7rem;
            border-radius: 6px;
            border: 1px solid var(--glass-border);
        }

        .picker-body {
            overflow-y: auto;
            flex: 1;
            padding: 0.5rem 0;
        }

        .picker-item {
            display: flex;
            align-items: center;
            gap: 0.7rem;
            padding: 0.55rem 1.5rem;
            cursor: pointer;
            font-size: 0.9rem;
            color: var(--text-primary);
            transition: background 0.15s;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .picker-item:hover {
            background: rgba(99, 102, 241, 0.1);
        }

        .picker-item.picker-up {
            color: var(--text-secondary);
            font-style: italic;
            border-bottom: 1px solid var(--glass-border);
            margin-bottom: 0.25rem;
        }

        .picker-item-icon {
            font-size: 1rem;
            flex-shrink: 0;
        }

        .picker-empty {
            padding: 2rem 1.5rem;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-style: italic;
        }

        .picker-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--glass-border);
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .picker-footer-path {
            flex: 1;
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-family: monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Locked path fields */
        .path-field-locked {
            opacity: 0.45;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="background-blob"></div>
    <div class="container">
        <!-- Connectivity Warning -->
        <div id="connection-warning" class="status-msg error"
            style="margin-bottom: 2rem; border-radius: var(--radius-lg); padding: 1.5rem; display: none;">
            <h3 style="color: var(--error-color); margin-bottom: 0.5rem; border-bottom: none;">‚ö†Ô∏è Server Not Connected
            </h3>
            <p style="font-size: 0.9rem; margin-bottom: 1rem;">You are accessing this page directly from your
                filesystem. The settings <b>cannot be saved</b> because the backend API is unreachable.</p>
            <p style="font-size: 0.8rem;">Please run <code>python app.py</code> and open <a href="http://localhost:5000"
                    style="color: var(--accent-color); font-weight: 600;">http://localhost:5000</a> instead.</p>
        </div>

        <header>
            <h1>Jellyfin Groupings</h1>
            <p class="subtitle">Create virtual Jellyfin libraries grouped by genre, actor, tag or external lists</p>
        </header>

        <!-- How It Works banner -->
        <div style="display: flex; gap: 1rem; margin-bottom: 2.5rem; flex-wrap: wrap;">
            <div
                style="flex: 1; min-width: 200px; background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: var(--radius-md); padding: 1.2rem; display: flex; gap: 1rem; align-items: flex-start;">
                <div
                    style="width: 32px; height: 32px; border-radius: 50%; background: var(--accent-color); display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.9rem; flex-shrink: 0;">
                    1</div>
                <div>
                    <div style="font-weight: 600; margin-bottom: 0.2rem;">Connect Jellyfin</div>
                    <div style="font-size: 0.8rem; color: var(--text-secondary);">Enter your server URL and API key so
                        this tool can read your library metadata.</div>
                </div>
            </div>
            <div
                style="flex: 1; min-width: 200px; background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: var(--radius-md); padding: 1.2rem; display: flex; gap: 1rem; align-items: flex-start;">
                <div
                    style="width: 32px; height: 32px; border-radius: 50%; background: var(--accent-color); display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.9rem; flex-shrink: 0;">
                    2</div>
                <div>
                    <div style="font-weight: 600; margin-bottom: 0.2rem;">Define Groupings</div>
                    <div style="font-size: 0.8rem; color: var(--text-secondary);">A grouping becomes a new Jellyfin
                        library. Choose what to group by (genre, actor, tag‚Ä¶) and give it a name.</div>
                </div>
            </div>
            <div
                style="flex: 1; min-width: 200px; background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: var(--radius-md); padding: 1.2rem; display: flex; gap: 1rem; align-items: flex-start;">
                <div
                    style="width: 32px; height: 32px; border-radius: 50%; background: var(--accent-color); display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.9rem; flex-shrink: 0;">
                    3</div>
                <div>
                    <div style="font-weight: 600; margin-bottom: 0.2rem;">Sync &amp; Add Libraries</div>
                    <div style="font-size: 0.8rem; color: var(--text-secondary);">Hit "Sync All Groupings" to create
                        symlinks on disk. Then <strong style="color: var(--text-primary);">manually add each folder as a
                            library</strong> in Jellyfin
                        (Content Type: <code style="font-size:0.75rem;">Mixed Movies and Shows</code>).</div>
                </div>
            </div>
        </div>

        <div class="main-grid">
            <section class="settings-column">
                <main class="card">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                        <h2 style="margin-bottom: 0;">‚ë† Server Settings</h2>
                        <div id="connection-status"
                            style="font-size: 0.8rem; font-weight: 600; color: var(--text-secondary);">
                            <span class="connection-dot" id="status-dot"></span>
                            <span id="status-text">Disconnected</span>
                        </div>
                    </div>
                    <p style="font-size: 0.82rem; color: var(--text-secondary); margin-bottom: 1.5rem;">Point this tool
                        at your Jellyfin server to get started.</p>
                    <form id="config-form">
                        <div class="form-group">
                            <label for="jellyfin_url">Jellyfin Server URL</label>
                            <input type="url" id="jellyfin_url" placeholder="https://jellyfin.yourdomain.com" required>
                            <small style="color: var(--text-secondary); font-size: 0.75rem;">The full URL to your
                                Jellyfin instance, including protocol and port if needed.</small>
                        </div>
                        <div class="form-group">
                            <label for="api_key">API Key</label>
                            <input type="password" id="api_key" placeholder="Enter your Jellyfin API Key" required>
                            <small style="color: var(--text-secondary); font-size: 0.75rem;">Generate at Jellyfin ‚Üí
                                Dashboard ‚Üí API Keys. This is used to read library metadata.</small>
                        </div>
                        <div class="form-group">
                            <label for="target_path">Base Target Path</label>
                            <div id="target_path_group" class="picker-row path-field-locked">
                                <input type="text" id="target_path" placeholder="/path/to/virtual/libraries" required
                                    disabled>
                                <button type="button" class="browse-btn" onclick="openPathPicker('target_path')"
                                    disabled title="Browse">üìÇ Browse</button>
                            </div>
                            <small style="color: var(--text-secondary); font-size: 0.75rem;">A folder on <em>this
                                    machine</em> where symlink folders will be created for each grouping. Jellyfin must
                                be able to see this path.</small>
                        </div>


                        <div class="form-group"
                            style="margin-top: 1rem; padding: 1rem; background: rgba(0,0,0,0.1); border-radius: var(--radius-md); border: 1px dashed var(--glass-border);">
                            <h3
                                style="font-size: 0.9rem; margin-bottom: 0.8rem; display: flex; align-items: center; gap: 0.5rem;">
                                <span>üóÇÔ∏è</span> Media Path Translation <span
                                    style="font-weight: 400; color: var(--text-secondary);">(Optional)</span>
                            </h3>
                            <p style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.8rem;">Only
                                needed when Jellyfin's media paths (from Docker or a remote server) differ from where
                                those files actually live on <em>this</em> machine. Leave blank if the paths match.
                            </p>
                            <div style="display: flex; flex-direction: column; gap: 1rem;">
                                <div>
                                    <label for="media_path_in_jellyfin" style="font-size: 0.75rem; opacity: 0.8;">Media
                                        path as Jellyfin sees it</label>
                                    <div id="media_path_in_jellyfin_group" class="picker-row path-field-locked">
                                        <input type="text" id="media_path_in_jellyfin" placeholder="e.g. /media"
                                            style="padding: 0.5rem; font-size: 0.85rem;" disabled>
                                        <button type="button" class="browse-btn"
                                            onclick="openPathPicker('media_path_in_jellyfin')" disabled
                                            title="Browse">üìÇ</button>
                                    </div>
                                </div>
                                <div>
                                    <label for="media_path_on_host" style="font-size: 0.75rem; opacity: 0.8;">Same path
                                        on this machine</label>
                                    <div id="media_path_on_host_group" class="picker-row path-field-locked">
                                        <input type="text" id="media_path_on_host" placeholder="e.g. /home/user/media"
                                            style="padding: 0.5rem; font-size: 0.85rem;" disabled>
                                        <button type="button" class="browse-btn"
                                            onclick="openPathPicker('media_path_on_host')" disabled
                                            title="Browse">üìÇ</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                            <button type="button" id="auto-detect-btn" onclick="autoDetectPaths()" class="secondary-btn"
                                style="border-color: var(--accent-color); color: var(--accent-color);">
                                <span class="loading-spinner"></span>
                                <span class="btn-text">‚ú® Auto-Detect Settings</span>
                            </button>
                            <button type="button" id="test-btn" onclick="testConnection()" class="secondary-btn">
                                <span class="loading-spinner"></span>
                                <span class="btn-text">Test Connection</span>
                            </button>
                        </div>
                        <button type="submit" id="save-btn" style="margin-top: 1rem; width: 100%;">
                            <span class="loading-spinner"></span>
                            <span class="btn-text">Save Server Settings</span>
                        </button>
                    </form>
                </main>

                <main class="card locked-section" id="maintenance-card" style="margin-top: 2rem;">
                    <div class="locked-overlay-text">Server Required</div>
                    <h2>‚ë¢ Sync &amp; Maintenance</h2>
                    <p style="font-size: 0.82rem; color: var(--text-secondary); margin-bottom: 1.2rem;">After defining
                        your groupings, press Sync to build the symlink folders on disk.</p>
                    <div
                        style="padding: 0.8rem 1rem; background: rgba(251,191,36,0.08); border: 1px solid rgba(251,191,36,0.3); border-radius: var(--radius-md); margin-bottom: 1rem;">
                        <p style="font-size: 0.78rem; color: #fbbf24; margin: 0; line-height: 1.5;">
                            ‚ö†Ô∏è <strong>Libraries are NOT created automatically.</strong><br>
                            After syncing, go to Jellyfin ‚Üí <strong>Dashboard ‚Üí Libraries ‚Üí Add Media
                                Library</strong>.<br>
                            Set <strong>Content Type</strong> to <code
                                style="font-size:0.75rem; background:rgba(0,0,0,0.2); padding: 0.1rem 0.3rem; border-radius:3px;">Mixed Movies and Shows</code>
                            and point it at each group's subfolder.
                        </p>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 1rem;">
                        <div>
                            <button id="sync-btn" onclick="syncAll()" class="primary-btn"
                                style="width: 100%; padding: 1rem; background: var(--accent-color); border: none; font-weight: 600;">
                                <span class="loading-spinner"></span>
                                <span class="btn-text">üöÄ Sync All Groupings</span>
                            </button>
                            <p
                                style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.4rem; text-align: center;">
                                Creates symlinks inside the Base Target Path for every defined grouping.</p>
                        </div>
                        <div>
                            <button id="preview-sync-btn" onclick="previewSyncAll()" class="secondary-btn"
                                style="width: 100%; padding: 1rem; font-weight: 600;">
                                <span class="loading-spinner"></span>
                                <span class="btn-text">üëÅÔ∏è Preview Sync</span>
                            </button>
                            <p
                                style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.4rem; text-align: center;">
                                See exactly what will be created without modifying the disk.</p>
                        </div>
                        <div>
                            <button id="cleanup-btn" onclick="openCleanupModal()" class="secondary-btn"
                                style="width: 100%; padding: 1rem; font-weight: 600; border-color: var(--error-color); color: var(--error-color);">
                                <span class="loading-spinner"></span>
                                <span class="btn-text">üßπ Clean Up Folders</span>
                            </button>
                            <p
                                style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.4rem; text-align: center;">
                                Delete old or unneeded grouping folders from your disk.</p>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div>
                                <button onclick="openExportModal()" class="secondary-btn"
                                    style="width: 100%; padding: 0.9rem;">‚¨á Export Config</button>
                                <p
                                    style="font-size: 0.72rem; color: var(--text-secondary); margin-top: 0.3rem; text-align: center;">
                                    Download settings &amp; groupings as JSON</p>
                            </div>
                            <div>
                                <button onclick="openImportModal()" class="secondary-btn"
                                    style="width: 100%; padding: 0.9rem;">‚¨Ü Import Config</button>
                                <p
                                    style="font-size: 0.72rem; color: var(--text-secondary); margin-top: 0.3rem; text-align: center;">
                                    Restore from a previously exported JSON</p>
                            </div>
                        </div>
                    </div>
                </main>
                <main class="card locked-section" id="scheduler-card" style="margin-top: 2rem;">
                    <div class="locked-overlay-text">Server Required</div>
                    <h2>‚ë£ Automatic Sync Scheduling</h2>
                    <p style="font-size: 0.82rem; color: var(--text-secondary); margin-bottom: 1.2rem;">Configure a
                        global
                        sync schedule to keep your libraries up to date automatically.</p>

                    <div class="form-group"
                        style="padding: 1rem; background: rgba(0,0,0,0.1); border-radius: var(--radius-md); border: 1px dashed var(--glass-border);">
                        <label
                            style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer; text-transform: none; font-size: 0.8rem; font-weight: 600; color: var(--text-secondary); letter-spacing: 0.05em; margin-bottom: 1rem;">
                            <input type="checkbox" id="global_scheduler_enabled" onchange="toggleGlobalScheduler(this)"
                                style="width: 16px; height: 16px; accent-color: var(--accent-color); cursor: pointer; flex-shrink: 0;">
                            <span style="text-transform: uppercase; letter-spacing: 0.05em;">Enable Global
                                Scheduler</span>
                        </label>

                        <div id="global_scheduler_panel" style="display: none;">
                            <label for="global_sync_schedule">Global Sync Schedule (Cron)</label>
                            <input type="text" id="global_sync_schedule" placeholder="0 0 * * * (Every midnight)"
                                style="margin-bottom: 0.5rem; width: 100%; padding: 0.8rem 1rem; background: rgba(0, 0, 0, 0.2); border: 1px solid var(--glass-border); border-radius: var(--radius-md); color: var(--text-primary);">
                            <small
                                style="color: var(--text-secondary); display: block; margin-top: 0.25rem; font-size: 0.75rem; margin-bottom: 1rem;">
                                Standard crontab expression: <code>minute hour day month day_of_week</code>.
                            </small>

                            <label style="margin-top: 1rem; display: block; margin-bottom: 0.5rem;">Excluded
                                Groupings</label>
                            <div id="global_sync_exclusions"
                                style="display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem; max-height: 150px; overflow-y: auto; padding-right: 0.5rem; background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: var(--radius-md);">
                                <!-- Checkboxes for each group to exclude -->
                            </div>
                            <small
                                style="color: var(--text-secondary); display: block; margin-top: 0.5rem; font-size: 0.75rem;">
                                These groupings will be skipped during the global scheduled sync.
                            </small>
                        </div>
                    </div>
                </main>
            </section>

            <section class="groupings-column locked-section" id="groupings-section">
                <div class="locked-overlay-text">Server Required</div>
                <main class="card" style="height: 100%; display: flex; flex-direction: column;">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                        <h2>‚ë° Groupings</h2>
                        <button onclick="clearAllGroups()" class="secondary-btn delete-btn"
                            style="padding: 0.5rem 0.8rem; font-size: 0.8rem; border: none;"
                            title="Remove All Groupings">
                            Clear All
                        </button>
                    </div>
                    <p style="font-size: 0.82rem; color: var(--text-secondary); margin-bottom: 1.5rem;">Each grouping
                        becomes a virtual Jellyfin library. Define as many as you like ‚Äî e.g. one per genre, actor, or
                        IMDb list.</p>

                    <div id="groups-list" style="margin: 0.5rem 0; flex: 1; min-height: 200px;">
                        <!-- Group cards will be injected here -->
                    </div>

                    <hr style="border: 0; border-top: 1px solid var(--glass-border); margin: 2rem 0;">

                    <h3 id="group-form-title">Create New Grouping</h3>
                    <form id="group-form" style="margin-top: 0.5rem;">
                        <div class="form-group">
                            <label for="group_name">Group Name</label>
                            <input type="text" id="group_name" placeholder="e.g. Action Movies" required>
                            <small style="color: var(--text-secondary); font-size: 0.75rem;">This becomes the folder
                                name and the Jellyfin library name.</small>
                        </div>
                        <div class="grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div class="form-group">
                                <label for="source_category">Source Category</label>
                                <select id="source_category" onchange="updateSourceTypeOptions()"
                                    style="width: 100%; padding: 0.8rem 1rem; background: rgba(0, 0, 0, 0.2); border: 1px solid var(--glass-border); border-radius: var(--radius-md); color: var(--text-primary); font-family: inherit; font-size: 1rem; appearance: none;">
                                    <option value="jellyfin">Jellyfin (Integrated)</option>
                                    <option value="external">External (3rd Party)</option>
                                </select>
                                <small style="color: var(--text-secondary); font-size: 0.75rem;">Use <em>Jellyfin</em>
                                    to filter by data already in your server, or <em>External</em> for IMDb / Trakt
                                    lists.</small>
                            </div>
                            <div class="form-group">
                                <label for="source_type">Filter By</label>
                                <select id="source_type" onchange="updateSourceValueUI()"
                                    style="width: 100%; padding: 0.8rem 1rem; background: rgba(0, 0, 0, 0.2); border: 1px solid var(--glass-border); border-radius: var(--radius-md); color: var(--text-primary); font-family: inherit; font-size: 1rem; appearance: none;">
                                    <!-- Options injected via JS -->
                                </select>
                                <small style="color: var(--text-secondary); font-size: 0.75rem;">The metadata field used
                                    to collect matching media into this grouping.</small>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="source_value">Filter Value</label>

                            <div id="metadata_rules_container"
                                style="display: none; flex-direction: column; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <!-- Filled by JS -->
                            </div>
                            <button type="button" onclick="addMetadataRule()" class="secondary-btn" id="add-rule-btn"
                                style="display: none; margin-bottom: 0.5rem; padding: 0.4rem 0.8rem; font-size: 0.85rem; width: fit-content;">+
                                Add Condition</button>

                            <div id="source_value_container"
                                style="display: flex; gap: 0.5rem; flex-direction: column;">
                                <input type="text" id="source_value" list="source_value_datalist"
                                    placeholder="e.g. Action  or  ls000024390" required
                                    style="width: 100%; padding: 0.8rem 1rem; background: rgba(0, 0, 0, 0.2); border: 1px solid var(--glass-border); border-radius: var(--radius-md); color: var(--text-primary); font-family: inherit; font-size: 1rem;">
                                <datalist id="source_value_datalist">
                                    <!-- Populated via JS -->
                                </datalist>
                                <button type="button" onclick="previewGrouping()" class="secondary-btn" id="preview-btn"
                                    style="padding: 0.6rem 1rem; font-size: 0.9rem; align-self: flex-start; margin-bottom: 0.25rem;">Preview
                                    Filter</button>
                            </div>
                            <small id="source_value_help"
                                style="color: var(--text-secondary); display: block; margin-top: 0.25rem; font-size: 0.75rem;">
                                The specific genre, actor name, tag, or list ID to include in this grouping.
                                <br><span style="color: var(--accent-color);">Tip: You can chain logic operators for
                                    complex filters: e.g. <code>Horror AND Action AND NOT Comedy</code></span>
                            </small>

                            <!-- Removed complex rules container, using free-text logical parsing -->
                            <div id="preview_result"
                                style="display: none; margin-top: 0.8rem; font-size: 0.8rem; padding: 1rem; background: rgba(0,0,0,0.2); border-radius: var(--radius-md); border: 1px dashed var(--glass-border);">
                            </div>
                        </div>
                        <div class="form-group">
                            <label
                                style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer; text-transform: none; font-size: 0.8rem; font-weight: 600; color: var(--text-secondary); letter-spacing: 0.05em;">
                                <input type="checkbox" id="sort_order_enabled" onchange="toggleSortOrder(this)"
                                    style="width: 16px; height: 16px; accent-color: var(--accent-color); cursor: pointer; flex-shrink: 0;">
                                <span style="text-transform: uppercase; letter-spacing: 0.05em;">Custom Sort Order <span
                                        style="font-weight:400; text-transform: none;">(optional)</span></span>
                            </label>
                            <div id="sort_order_panel" style="display: none; margin-top: 0.75rem;">
                                <select id="sort_order"
                                    style="width: 100%; padding: 0.8rem 1rem; background: rgba(0, 0, 0, 0.2); border: 1px solid var(--glass-border); border-radius: var(--radius-md); color: var(--text-primary); font-family: inherit; font-size: 1rem; appearance: none;">
                                    <option value="">None (filesystem order)</option>
                                    <option value="imdb_list_order">üìã IMDb List Order</option>
                                    <option value="trakt_list_order">üìã Trakt List Order</option>
                                    <option value="tmdb_list_order">üéûÔ∏è TMDb List Order</option>
                                    <option value="anilist_list_order">üé® AniList List Order</option>
                                    <option value="mal_list_order">üìã MyAnimeList List Order</option>
                                    <option value="letterboxd_list_order">üìã Letterboxd List Order</option>
                                    <option value="CommunityRating">‚≠ê Community Rating (highest first)</option>
                                    <option value="ProductionYear">üìÖ Production Year (newest first)</option>
                                    <option value="SortName">üî§ Name (A ‚Üí Z)</option>
                                    <option value="DateCreated">üïê Date Added (newest first)</option>
                                    <option value="Random">üé≤ Random</option>
                                </select>
                                <small
                                    style="color: var(--text-secondary); display: block; margin-top: 0.25rem; font-size: 0.75rem;">
                                    Symlinks are named <code style="font-size:0.7rem;">0001 - Title</code>, <code
                                        style="font-size:0.7rem;">0002 - Title</code>‚Ä¶ so Jellyfin's "Sort by Name"
                                    reflects this order. List Order options only work with their corresponding list
                                    source type.
                                </small>
                            </div>
                        </div>
                        <div class="form-group">
                            <label
                                style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer; text-transform: none; font-size: 0.8rem; font-weight: 600; color: var(--text-secondary); letter-spacing: 0.05em;">
                                <input type="checkbox" id="schedule_enabled" onchange="toggleGroupScheduler(this)"
                                    style="width: 16px; height: 16px; accent-color: var(--accent-color); cursor: pointer; flex-shrink: 0;">
                                <span style="text-transform: uppercase; letter-spacing: 0.05em;">Individual Sync
                                    Schedule <span
                                        style="font-weight:400; text-transform: none;">(optional)</span></span>
                            </label>
                            <div id="group_scheduler_panel" style="display: none; margin-top: 0.75rem;">
                                <input type="text" id="group_schedule" placeholder="e.g. 0 12 * * * (Every day at noon)"
                                    style="width: 100%; padding: 0.8rem 1rem; background: rgba(0, 0, 0, 0.2); border: 1px solid var(--glass-border); border-radius: var(--radius-md); color: var(--text-primary); font-family: inherit; font-size: 1rem;">
                                <small
                                    style="color: var(--text-secondary); display: block; margin-top: 0.25rem; font-size: 0.75rem;">
                                    Standard crontab expression. Leave empty to use only the global schedule.
                                </small>
                            </div>
                        </div>
                        <div style="display: flex; gap: 1rem;">
                            <button type="submit" id="add-group-btn"
                                style="flex: 2; background: var(--surface-color); border: 1px solid var(--accent-color); color: var(--accent-color);">
                                Add Grouping
                            </button>
                            <button type="button" id="cancel-edit-btn" onclick="cancelEdit()"
                                style="flex: 1; display: none; background: transparent; border: 1px solid var(--text-secondary); color: var(--text-secondary);">
                                Cancel
                            </button>
                        </div>
                    </form>
                </main>

                <main class="card" style="margin-top: 2rem;">
                    <h3>External API Connections</h3>
                    <p style="font-size: 0.82rem; color: var(--text-secondary); margin-bottom: 1.5rem;">Configure
                        optional 3rd-party services to use as grouping sources.</p>

                    <form id="api-config-form">
                        <div class="form-group"
                            style="margin-top: 0.8rem; padding: 1rem; background: rgba(0,0,0,0.1); border-radius: var(--radius-md); border: 1px dashed var(--glass-border);">
                            <h3
                                style="font-size: 0.9rem; margin-bottom: 0.8rem; display: flex; align-items: center; gap: 0.5rem;">
                                <span>üì°</span> Trakt API <span
                                    style="font-weight: 400; color: var(--text-secondary);">(Optional)</span>
                            </h3>
                            <p style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.8rem;">Only
                                needed for Trakt lists. Create an app at
                                <a href="https://trakt.tv/oauth/applications/new" target="_blank"
                                    style="color: var(--accent-color);">trakt.tv/oauth/applications</a>.
                            </p>
                            <label for="trakt_client_id" style="font-size: 0.75rem; opacity: 0.8;">Trakt Client
                                ID</label>
                            <input type="text" id="trakt_client_id" placeholder="Your Trakt API Client ID"
                                style="padding: 0.5rem; font-size: 0.85rem;">
                        </div>

                        <div class="form-group"
                            style="margin-top: 0.8rem; padding: 1rem; background: rgba(0,0,0,0.1); border-radius: var(--radius-md); border: 1px dashed var(--glass-border);">
                            <h3
                                style="font-size: 0.9rem; margin-bottom: 0.8rem; display: flex; align-items: center; gap: 0.5rem;">
                                <span>üé¨</span> TMDb API <span
                                    style="font-weight: 400; color: var(--text-secondary);">(Optional)</span>
                            </h3>
                            <p style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.8rem;">Only
                                needed for TMDb lists. Get your v3 API Key at
                                <a href="https://www.themoviedb.org/settings/api" target="_blank"
                                    style="color: var(--accent-color);">themoviedb.org/settings/api</a>.
                            </p>
                            <label for="tmdb_api_key" style="font-size: 0.75rem; opacity: 0.8;">TMDb API Key</label>
                            <input type="text" id="tmdb_api_key" placeholder="Your TMDb API Key"
                                style="padding: 0.5rem; font-size: 0.85rem;">
                        </div>

                        <div class="form-group"
                            style="margin-top: 0.8rem; padding: 1rem; background: rgba(0,0,0,0.1); border-radius: var(--radius-md); border: 1px dashed var(--glass-border);">
                            <h3
                                style="font-size: 0.9rem; margin-bottom: 0.8rem; display: flex; align-items: center; gap: 0.5rem;">
                                <span>üì∫</span> MyAnimeList API <span
                                    style="font-weight: 400; color: var(--text-secondary);">(Optional)</span>
                            </h3>
                            <p style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.8rem;">Only
                                needed for MAL lists. Get your Client ID at
                                <a href="https://myanimelist.net/apiconfig" target="_blank"
                                    style="color: var(--accent-color);">myanimelist.net/apiconfig</a>.
                            </p>
                            <label for="mal_client_id" style="font-size: 0.75rem; opacity: 0.8;">MAL Client ID</label>
                            <input type="text" id="mal_client_id" placeholder="Your MyAnimeList API Client ID"
                                style="padding: 0.5rem; font-size: 0.85rem;">
                        </div>

                        <button type="submit" id="save-apis-btn" style="margin-top: 1rem; width: 100%;">
                            <span class="loading-spinner"></span>
                            <span class="btn-text">Save API Keys</span>
                        </button>
                    </form>
                </main>
            </section>
        </div>

        <!-- Export Modal -->
        <div id="export-modal" class="modal"
            style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; backdrop-filter: blur(8px);">
            <div class="card" style="max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
                <h2>Export Settings</h2>
                <div class="form-group" style="margin-bottom: 2rem;">
                    <label>What do you want to export?</label>
                    <div style="display: flex; flex-direction: column; gap: 1rem; margin-top: 1rem;">
                        <label
                            style="display: flex; align-items: center; gap: 1rem; text-transform: none; cursor: pointer;">
                            <input type="radio" name="export-type" value="all" checked
                                onchange="toggleExportSelection()">
                            Full Configuration (Settings + All Groups)
                        </label>
                        <label
                            style="display: flex; align-items: center; gap: 1rem; text-transform: none; cursor: pointer;">
                            <input type="radio" name="export-type" value="selective" onchange="toggleExportSelection()">
                            Selected Groupings Only
                        </label>
                    </div>
                </div>

                <div id="export-selection-list"
                    style="display: none; border-top: 1px solid var(--glass-border); padding-top: 1rem; margin-bottom: 1.5rem;">
                    <label>Select Groups</label>
                    <div id="export-groups-container"></div>
                </div>

                <div style="display: flex; gap: 1rem;">
                    <button onclick="execExport()" style="flex: 2;">Download Export</button>
                    <button onclick="closeModal('export-modal')" class="secondary-btn"
                        style="flex: 1; border-color: var(--error-color); color: var(--error-color);">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Import Modal -->
        <div id="import-modal" class="modal"
            style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; backdrop-filter: blur(8px);">
            <div class="card" style="max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
                <h2>Import Settings</h2>

                <div id="import-step-1">
                    <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">Select a file to begin the import
                        process.</p>
                    <button onclick="document.getElementById('import-file-input').click()" style="width: 100%;">Select
                        JSON File</button>
                    <input type="file" id="import-file-input" style="display: none;" accept=".json"
                        onchange="handleFileSelected(event)">
                </div>

                <div id="import-step-2" style="display: none;">
                    <div id="import-warning" class="status-msg error" style="margin-bottom: 1.5rem; display: none;">
                        WARNING: This will overwrite your entire current configuration!
                    </div>
                    <div id="import-selection-list">
                        <label>Select items to import</label>
                        <div id="import-groups-container" style="margin-top: 0.5rem;"></div>
                    </div>
                    <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                        <button id="confirm-import" style="flex: 2;">Confirm Import</button>
                        <button onclick="closeModal('import-modal')" class="secondary-btn"
                            style="flex: 1;">Cancel</button>
                    </div>
                </div>

                <button id="cancel-import-top" onclick="closeModal('import-modal')" class="secondary-btn"
                    style="margin-top: 1.5rem; width: 100%;">Cancel</button>
            </div>
        </div>

        <!-- Preview Sync Modal -->
        <div id="preview-sync-modal" class="modal"
            style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; backdrop-filter: blur(8px);">
            <div class="card"
                style="max-width: 700px; width: 90%; max-height: 85vh; display: flex; flex-direction: column;">
                <h2>Preview Sync</h2>
                <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">This is a dry-run. No
                    files or folders will be created on disk.</p>

                <div id="preview-sync-results"
                    style="flex: 1; overflow-y: auto; padding-right: 0.5rem; margin-bottom: 1rem; display: flex; flex-direction: column; gap: 1rem;">
                    <!-- Results populated by JS -->
                </div>

                <div style="display: flex; gap: 1rem; margin-top: auto;">
                    <button onclick="closeModal('preview-sync-modal')" class="secondary-btn"
                        style="flex: 1; width: 100%;">Close</button>
                </div>
            </div>
        </div>

        <!-- Cleanup Modal -->
        <div id="cleanup-modal" class="modal"
            style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; backdrop-filter: blur(8px);">
            <div class="card"
                style="max-width: 500px; width: 90%; max-height: 80vh; display: flex; flex-direction: column;">
                <h2>Clean Up Folders</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem; font-size: 0.85rem;">Select the folders
                    you want to delete from the target directory.</p>

                <div id="cleanup-loading" style="display: flex; justify-content: center; padding: 2rem;">
                    <div class="loading-spinner" style="border-top-color: var(--accent-color); display: block;"></div>
                </div>

                <div id="cleanup-error" class="status-msg error" style="display: none; margin-bottom: 1rem;"></div>

                <div id="cleanup-content" style="display: none; flex: 1; min-height: 0; flex-direction: column;">
                    <div id="cleanup-list"
                        style="border: 1px solid var(--glass-border); border-radius: var(--radius-md); padding: 0.5rem; overflow-y: auto; margin-bottom: 1.5rem; background: rgba(0,0,0,0.2);">
                        <!-- Filled by JS -->
                    </div>

                    <div style="display: flex; gap: 1rem; margin-top: auto;">
                        <button id="confirm-cleanup-btn" onclick="execCleanup()"
                            style="flex: 2; background: var(--error-color); border-color: var(--error-color);">Delete
                            Selected <span id="cleanup-count"></span></button>
                        <button onclick="closeModal('cleanup-modal')" class="secondary-btn"
                            style="flex: 1;">Cancel</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Cover Generator Modal -->
        <div id="cover-generator-modal" class="modal"
            style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; justify-content: center; align-items: center; backdrop-filter: blur(8px);">
            <div class="card"
                style="max-width: 800px; width: 90%; max-height: 90vh; display: flex; flex-direction: column;">
                <h2>üé® Generate Cover (16:9)</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 1.5rem; margin-bottom: 1.5rem;">
                    <!-- Row 1: Primary Content (Text) -->
                    <div style="grid-column: span 3;">
                        <label for="cover-text"
                            style="font-size: 0.75rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem; display: block;">Cover
                            Text</label>
                        <input type="text" id="cover-text"
                            style="width: 100%; padding: 0.75rem 1rem; background: rgba(0,0,0,0.3); border: 1px solid var(--glass-border); border-radius: var(--radius-md); color: var(--text-primary); font-size: 1.1rem; outline: none; transition: var(--transition);"
                            oninput="renderCover()" placeholder="Enter group name...">
                    </div>

                    <!-- Row 2: Aesthetics & Style -->
                    <div style="min-width: 0;">
                        <label for="cover-theme"
                            style="font-size: 0.75rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem; display: block;">Theme</label>
                        <select id="cover-theme" onchange="renderCover()"
                            style="width: 100%; padding: 0.7rem; background: rgba(0,0,0,0.3); border: 1px solid var(--glass-border); border-radius: var(--radius-md); color: var(--text-primary); cursor: pointer;">
                            <option value="modern-dark">Dark Gradient (Modern)</option>
                            <option value="vibrant-glow">Vibrant Glow</option>
                            <option value="minimal-glass">Minimal Glassmorphism</option>
                            <option value="cyberpunk">Cyberpunk Night</option>
                            <option value="aurora">Aurora Borealis</option>
                            <option value="monochrome">Monochrome Peak</option>
                            <option value="vintage">Golden Age</option>
                        </select>
                    </div>
                    <div style="min-width: 0;">
                        <label for="cover-border-style"
                            style="font-size: 0.75rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem; display: block;">Border
                            Style</label>
                        <select id="cover-border-style" onchange="renderCover()"
                            style="width: 100%; padding: 0.7rem; background: rgba(0,0,0,0.3); border: 1px solid var(--glass-border); border-radius: var(--radius-md); color: var(--text-primary); cursor: pointer;">
                            <option value="none">None</option>
                            <option value="elegant">Elegant Thin</option>
                            <option value="bold-frame">Bold Frame</option>
                            <option value="neon-glow">Neon Glow</option>
                            <option value="tech-corners">Sci-Fi Corners</option>
                            <option value="double-inset">Double Inset</option>
                            <option value="corner-brackets">Corner Brackets</option>
                            <option value="industrial-dash">Dashed Industrial</option>
                            <option value="ornate">Ornate Frame</option>
                        </select>
                    </div>
                    <div
                        style="display: flex; gap: 0.75rem; align-items: flex-end; background: rgba(255,255,255,0.03); padding: 0.5rem 0.75rem; border-radius: var(--radius-md); border: 1px solid var(--glass-border);">
                        <div>
                            <label for="cover-border-color"
                                style="font-size: 0.65rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 0.3rem; display: block;">Border</label>
                            <input type="color" id="cover-border-color" value="#ffffff" onchange="renderCover()"
                                style="width: 44px; height: 32px; padding: 0; border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; cursor: pointer; background: transparent;">
                        </div>
                        <div>
                            <label for="cover-color-1"
                                style="font-size: 0.65rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 0.3rem; display: block;">Color
                                1</label>
                            <input type="color" id="cover-color-1" value="#4f46e5" onchange="renderCover()"
                                style="width: 44px; height: 32px; padding: 0; border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; cursor: pointer; background: transparent;">
                        </div>
                        <div>
                            <label for="cover-color-2"
                                style="font-size: 0.65rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 0.3rem; display: block;">Color
                                2</label>
                            <input type="color" id="cover-color-2" value="#9333ea" onchange="renderCover()"
                                style="width: 44px; height: 32px; padding: 0; border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; cursor: pointer; background: transparent;">
                        </div>
                    </div>
                </div>
                <div
                    style="flex: 1; display: flex; justify-content: center; align-items: center; background: rgba(0,0,0,0.3); border-radius: var(--radius-md); padding: 1rem; overflow: hidden; border: 1px dashed var(--glass-border); min-height: 350px;">
                    <canvas id="cover-canvas" width="1920" height="1080"
                        style="max-width: 100%; max-height: 50vh; object-fit: contain; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);"></canvas>
                </div>
                <div style="display: flex; gap: 1rem; margin-top: 1.5rem;">
                    <button type="button" onclick="applyCover()" style="flex: 2; font-weight: 600;">Apply Cover</button>
                    <button type="button" onclick="closeModal('cover-generator-modal')" class="secondary-btn"
                        style="flex: 1;">Cancel</button>
                </div>
            </div>
        </div>

        <div id="status-msg" class="status-msg"></div>

        <!-- Folder Picker Modal -->
        <div id="path-picker-modal" onclick="pickerOutsideClick(event)">
            <div class="picker-box">
                <div class="picker-header">
                    <div class="picker-title" id="picker-title">Select Folder</div>
                    <div class="picker-breadcrumb" id="picker-breadcrumb">/</div>
                </div>
                <div class="picker-body" id="picker-body"></div>
                <div class="picker-footer">
                    <span class="picker-footer-path" id="picker-footer-path">No folder selected</span>
                    <button onclick="closePicker()" class="secondary-btn"
                        style="width:auto;padding:0.6rem 1.1rem;margin:0;">Cancel</button>
                    <button onclick="confirmPicker()" style="width:auto;padding:0.6rem 1.2rem;margin:0;">Select</button>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>Run <code>python app.py</code> to start the backend &nbsp;¬∑&nbsp; Jellyfin Groupings</p>
        </div>
    </div>

    <script>
        const configForm = document.getElementById('config-form');
        const apiConfigForm = document.getElementById('api-config-form');
        const groupForm = document.getElementById('group-form');
        const groupFormTitle = document.getElementById('group-form-title');
        const addGroupBtn = document.getElementById('add-group-btn');
        const cancelEditBtn = document.getElementById('cancel-edit-btn');
        const saveBtn = document.getElementById('save-btn');
        const saveApisBtn = document.getElementById('save-apis-btn');
        const testBtn = document.getElementById('test-btn');
        const statusMsg = document.getElementById('status-msg');
        const groupsList = document.getElementById('groups-list');

        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const maintenanceCard = document.getElementById('maintenance-card');
        const groupingsSection = document.getElementById('groupings-section');

        const sourceValueInput = document.getElementById('source_value');
        const sourceValueSelect = document.getElementById('source_value_select');
        const sourceValueHelp = document.getElementById('source_value_help');

        const sourceOptions = {
            jellyfin: [
                { value: 'general', label: 'General (Title, Date, Rating...)' },
                { value: 'genre', label: 'Genre' },
                { value: 'actor', label: 'Actor' },
                { value: 'studio', label: 'Studio' },
                { value: 'tag', label: 'Jellyfin Tag' },
                { value: 'complex', label: 'Complex Rule-set (Mixed)' }
            ],
            external: [
                { value: 'imdb_list', label: 'IMDb List' },
                { value: 'trakt_list', label: 'Trakt List', requiredKey: 'trakt_client_id' },
                { value: 'tmdb_list', label: 'TMDb List', requiredKey: 'tmdb_api_key' },
                { value: 'anilist_list', label: 'AniList List' },
                { value: 'mal_list', label: 'MyAnimeList List', requiredKey: 'mal_client_id' },
                { value: 'letterboxd_list', label: 'Letterboxd List' }
            ]
        };

        const metadataTypes = ['genre', 'actor', 'studio', 'tag', 'complex'];

        let currentConfig = { groups: [] };
        let pendingImportData = null;
        let editingIndex = -1;
        let isServerValidated = false;
        let cachedMetadata = {};
        let lastRenderedType = null;
        window._currentMetadataRules = [{ operator: '', value: '' }];

        function getFilterValue() {
            const type = document.getElementById('source_type').value;
            const isMetadataType = metadataTypes.includes(type);
            if (isMetadataType && isServerValidated) {
                const validRules = window._currentMetadataRules.filter(r => r.value && r.value.trim() !== '');
                if (validRules.length === 0) return '';
                const parts = validRules.map((r, i) => {
                    const prefix = type === 'complex' ? `${r.type || 'genre'}:` : '';
                    return i === 0 ? `${prefix}${r.value.trim()}` : `${r.operator} ${prefix}${r.value.trim()}`;
                });
                return parts.join(' ');
            }
            return document.getElementById('source_value').value.trim();
        }

        function parseMetadataValue(valStr) {
            if (!valStr || valStr.trim() === '') return [{ operator: '', value: '' }];
            const pattern = /\s+(AND NOT|OR NOT|AND|OR)\s+/i;
            const parts = valStr.split(pattern);
            const rules = [];

            const parseRule = (s) => {
                const match = s.trim().match(/^(\w+):(.+)$/);
                if (match) return { type: match[1], value: match[2].trim() };
                return { value: s.trim() };
            };

            const first = parseRule(parts[0]);
            rules.push({ operator: '', ...first });

            for (let i = 1; i < parts.length; i += 2) {
                const rest = parseRule(parts[i + 1]);
                rules.push({ operator: parts[i].trim().toUpperCase().replace(/\s+/g, ' '), ...rest });
            }
            return rules;
        }

        function renderMetadataRules() {
            const container = document.getElementById('metadata_rules_container');
            container.innerHTML = '';
            const type = document.getElementById('source_type').value;

            window._currentMetadataRules.forEach((rule, index) => {
                const row = document.createElement('div');
                row.setAttribute('style', 'display: flex; gap: 0.5rem; align-items: center; width: 100%;');

                if (index > 0) {
                    const opSelect = document.createElement('select');
                    opSelect.setAttribute('style', 'flex: 0 0 auto; padding: 0.8rem; background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border); border-radius: var(--radius-md); color: var(--text-primary); font-size: 0.9rem; font-weight: 600;');
                    const ops = ['AND', 'OR', 'AND NOT', 'OR NOT'];
                    ops.forEach(op => {
                        const o = document.createElement('option');
                        o.value = op;
                        o.textContent = op;
                        if (rule.operator === op) o.selected = true;
                        opSelect.appendChild(o);
                    });
                    opSelect.onchange = (e) => { rule.operator = e.target.value; };
                    row.appendChild(opSelect);
                }

                if (type === 'complex') {
                    const rowTypeSelect = document.createElement('select');
                    rowTypeSelect.setAttribute('style', 'flex: 0 0 auto; width: 110px; padding: 0.8rem; background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border); border-radius: var(--radius-md); color: var(--text-primary); font-size: 0.9rem;');
                    const types = ['genre', 'actor', 'studio', 'tag'];
                    types.forEach(t => {
                        const o = document.createElement('option');
                        o.value = t;
                        o.textContent = t.charAt(0).toUpperCase() + t.slice(1);
                        if (rule.type === t || (!rule.type && t === 'genre')) o.selected = true;
                        if (!rule.type) rule.type = 'genre';
                        rowTypeSelect.appendChild(o);
                    });
                    rowTypeSelect.onchange = (e) => {
                        rule.type = e.target.value;
                        renderMetadataRules();
                    };
                    row.appendChild(rowTypeSelect);
                }

                const rowType = type === 'complex' ? (rule.type || 'genre') : type;
                const options = cachedMetadata[rowType] || [];

                const valSelect = document.createElement('select');
                valSelect.setAttribute('style', 'flex: 1; padding: 0.8rem 1rem; background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border); border-radius: var(--radius-md); color: var(--text-primary); font-size: 1rem;');

                const defaultOpt = document.createElement('option');
                defaultOpt.value = '';
                defaultOpt.textContent = 'Select ' + rowType + '...';
                defaultOpt.disabled = true;
                defaultOpt.selected = !rule.value;
                valSelect.appendChild(defaultOpt);

                let foundMatch = false;
                options.forEach(opt => {
                    const o = document.createElement('option');
                    o.value = opt;
                    o.textContent = opt;
                    if (rule.value === opt) { o.selected = true; foundMatch = true; }
                    valSelect.appendChild(o);
                });

                if (rule.value && !foundMatch) {
                    const o = document.createElement('option');
                    o.value = rule.value;
                    o.textContent = rule.value + " (Unavailable/Custom)";
                    o.selected = true;
                    valSelect.appendChild(o);
                }

                valSelect.onchange = (e) => { rule.value = e.target.value; };
                row.appendChild(valSelect);

                if (index > 0) {
                    const rmBtn = document.createElement('button');
                    rmBtn.type = 'button';
                    rmBtn.innerHTML = '<svg width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/></svg>';
                    rmBtn.className = 'delete-btn';
                    rmBtn.title = 'Remove condition';
                    rmBtn.setAttribute('style', 'padding: 0; width: 38px; height: 38px; display:flex; align-items:center; justify-content:center; margin: 0; flex-shrink: 0;');
                    rmBtn.onclick = () => {
                        window._currentMetadataRules.splice(index, 1);
                        renderMetadataRules();
                    };
                    row.appendChild(rmBtn);
                }

                container.appendChild(row);
            });
        }

        function toggleGlobalScheduler(cb) {
            const panel = document.getElementById('global_scheduler_panel');
            if (panel) panel.style.display = cb.checked ? 'block' : 'none';
        }

        function toggleGroupScheduler(cb) {
            const panel = document.getElementById('group_scheduler_panel');
            if (panel) panel.style.display = cb.checked ? 'block' : 'none';
        }

        function updateGlobalSyncExclusionsUI() {
            const container = document.getElementById('global_sync_exclusions');
            if (!container) return;
            container.innerHTML = '';

            if (!currentConfig.scheduler) {
                currentConfig.scheduler = { global_enabled: false, global_schedule: '', global_exclude_ids: [] };
            }
            if (!currentConfig.scheduler.global_exclude_ids) {
                currentConfig.scheduler.global_exclude_ids = [];
            }

            // Prune stale group names from global_exclude_ids
            const validGroupNames = currentConfig.groups.map(g => g.name).filter(Boolean);
            currentConfig.scheduler.global_exclude_ids = currentConfig.scheduler.global_exclude_ids.filter(id => validGroupNames.includes(id));

            const excludedIds = currentConfig.scheduler.global_exclude_ids;

            currentConfig.groups.forEach((group) => {
                if (!group.name) return;
                const label = document.createElement('label');
                label.setAttribute('style', 'display: flex; align-items: center; gap: 0.6rem; cursor: pointer; font-size: 0.85rem; padding: 0.2rem 0;');

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.checked = excludedIds.includes(group.name);
                cb.setAttribute('style', 'width:16px; height:16px; accent-color: var(--accent-color);');
                cb.onchange = (e) => {
                    const idx = excludedIds.indexOf(group.name);
                    if (e.target.checked) {
                        if (idx === -1) excludedIds.push(group.name);
                    } else {
                        if (idx !== -1) excludedIds.splice(idx, 1);
                    }
                };

                label.appendChild(cb);
                label.appendChild(document.createTextNode(group.name));
                container.appendChild(label);
            });

            if (currentConfig.groups.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.8rem; font-style: italic;">No groups defined yet.</p>';
            }
        }

        function addMetadataRule() {
            window._currentMetadataRules.push({ operator: 'AND', value: '' });
            renderMetadataRules();
        }

        async function previewGrouping() {
            const type = document.getElementById('source_type').value;
            const val = getFilterValue();
            const resultDiv = document.getElementById('preview_result');

            if (!metadataTypes.includes(type) && type !== 'general') {
                resultDiv.style.display = 'block';
                resultDiv.innerHTML = '<span style="color:var(--text-secondary);">Preview mostly supports Jellyfin library metadata types (Genre, Actor, etc). Try connecting server or checking other logs.</span>';
                return;
            }

            if (!val) {
                resultDiv.style.display = 'block';
                resultDiv.innerHTML = '<span style="color:var(--error-color);">Please enter a filter value to preview.</span>';
                return;
            }

            resultDiv.style.display = 'block';
            resultDiv.innerHTML = '<span class="loading-spinner" style="display:inline-block; margin-right: 0.5rem; border-color: rgba(255,255,255,0.2); border-left-color: var(--accent-color);"></span> <span style="color: var(--text-secondary);">Loading preview...</span>';

            try {
                const response = await fetch('/api/grouping/preview', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ type: type, value: val })
                });
                const res = await response.json();
                resultDiv.innerHTML = '';
                if (res.status === 'success') {
                    const summaryLine = document.createElement('div');
                    const labelStrong = document.createElement('strong');
                    labelStrong.setAttribute('style', 'color:var(--text-primary);');
                    labelStrong.textContent = 'Estimated Items: ';
                    const countSpan = document.createElement('span');
                    countSpan.setAttribute('style', 'color:var(--accent-color); font-weight:600;');
                    countSpan.textContent = String(res.count);
                    summaryLine.appendChild(labelStrong);
                    summaryLine.appendChild(countSpan);
                    resultDiv.appendChild(summaryLine);

                    if (res.count > 0) {
                        const matchesLabel = document.createElement('strong');
                        matchesLabel.textContent = 'First matches:';
                        matchesLabel.setAttribute('style', 'display:block; margin-top:0.6rem;');
                        resultDiv.appendChild(matchesLabel);

                        const ul = document.createElement('ul');
                        ul.setAttribute('style', 'margin-top:0.4rem; padding-left:1.5rem; color:var(--text-secondary);');
                        res.preview_items.forEach(item => {
                            const li = document.createElement('li');
                            li.textContent = item.Year ? `${item.Name} (${item.Year})` : item.Name;
                            ul.appendChild(li);
                        });
                        resultDiv.appendChild(ul);
                    }
                } else {
                    const errSpan = document.createElement('span');
                    errSpan.setAttribute('style', 'color:var(--error-color);');
                    errSpan.textContent = `Error: ${res.message}`;
                    resultDiv.appendChild(errSpan);
                }
            } catch (e) {
                resultDiv.innerHTML = '<span style="color:var(--error-color);">Network error during preview.</span>';
            }
        }

        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                currentConfig = await response.json();
                currentConfig.groups = currentConfig.groups || [];

                // Backwards compatibility / Data Migration
                currentConfig.groups.forEach(g => {
                    if (!g.source_category) {
                        if (['imdb_list', 'trakt_list'].includes(g.source_type)) {
                            g.source_category = 'external';
                        } else {
                            g.source_category = 'jellyfin';
                            if (g.source_type === 'jellyfin_tag') g.source_type = 'tag';
                            if (g.source_type === 'people') g.source_type = 'actor';
                        }
                    } else if (g.source_type === 'people') {
                        // Handle cases where category was set but type was still old
                        g.source_type = 'actor';
                    }
                });

                document.getElementById('jellyfin_url').value = currentConfig.jellyfin_url || '';
                document.getElementById('api_key').value = currentConfig.api_key || '';
                document.getElementById('target_path').value = currentConfig.target_path || '';
                document.getElementById('media_path_in_jellyfin').value = currentConfig.media_path_in_jellyfin || currentConfig.jellyfin_root || '';
                document.getElementById('media_path_on_host').value = currentConfig.media_path_on_host || currentConfig.host_root || '';
                document.getElementById('trakt_client_id').value = currentConfig.trakt_client_id || '';
                document.getElementById('tmdb_api_key').value = currentConfig.tmdb_api_key || '';
                document.getElementById('mal_client_id').value = currentConfig.mal_client_id || '';

                // Scheduler settings
                const sched = currentConfig.scheduler || { global_enabled: false, global_schedule: '', global_exclude_ids: [] };
                document.getElementById('global_scheduler_enabled').checked = sched.global_enabled;
                document.getElementById('global_sync_schedule').value = sched.global_schedule || '';
                toggleGlobalScheduler(document.getElementById('global_scheduler_enabled'));

                updateSourceTypeOptions();
                renderGroups();

                // Initial silent test if we have config
                if (currentConfig.jellyfin_url && currentConfig.api_key) {
                    await performSilentTest();
                }
            } catch (err) {
                showStatus('Failed to load configuration', 'error');
            }
        }

        async function performSilentTest() {
            const data = {
                jellyfin_url: currentConfig.jellyfin_url,
                api_key: currentConfig.api_key
            };
            try {
                const response = await fetch('/api/test-server', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                const result = await response.json();
                const isValid = result.status === 'success';
                updateValidationUI(isValid);
                if (isValid) refreshMetadata();
            } catch (err) {
                updateValidationUI(false);
            }
        }

        async function testConnection() {
            testBtn.classList.add('btn-loading');
            const data = {
                jellyfin_url: document.getElementById('jellyfin_url').value,
                api_key: document.getElementById('api_key').value
            };

            try {
                const response = await fetch('/api/test-server', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                const result = await response.json();

                if (result.status === 'success') {
                    showStatus(result.message, 'success');
                    updateValidationUI(true);
                    // Also save if successful to lock in the working settings
                    currentConfig.jellyfin_url = data.jellyfin_url;
                    currentConfig.api_key = data.api_key;
                    currentConfig.target_path = document.getElementById('target_path').value;
                    await saveAllConfig();
                    await refreshMetadata();
                    // Auto-detect paths only if fields are currently empty
                    await autoDetectIfEmpty();
                } else {
                    showStatus(result.message || 'Connection failed', 'error');
                    updateValidationUI(false);
                }
            } catch (err) {
                showStatus('Connection test failed - API unreachable', 'error');
                updateValidationUI(false);
            } finally {
                testBtn.classList.remove('btn-loading');
            }
        }

        async function refreshMetadata() {
            try {
                // We've deleted the old `<select>`, no loading state required. Data populates into the dropdown silently
                const response = await fetch('/api/jellyfin/metadata');
                const result = await response.json();
                if (result.status === 'success') {
                    cachedMetadata = result.metadata;
                    updateSourceValueUI();
                } else {
                    console.error('Failed to load metadata from Jellyfin server');
                }
            } catch (err) {
                console.error('Failed to fetch metadata:', err);
            }
        }

        function updateSourceTypeOptions() {
            const category = document.getElementById('source_category').value;
            const typeSelect = document.getElementById('source_type');
            const currentValue = typeSelect.value;

            typeSelect.innerHTML = '';
            sourceOptions[category].forEach(opt => {
                const o = document.createElement('option');
                o.value = opt.value;

                // Check if this option requires an API key that is currently missing
                let isDisabled = false;
                if (opt.requiredKey && (!currentConfig[opt.requiredKey] || currentConfig[opt.requiredKey].trim() === '')) {
                    isDisabled = true;
                }

                if (isDisabled) {
                    o.textContent = `${opt.label} (Keys missing - see Server Settings)`;
                    o.disabled = true;
                } else {
                    o.textContent = opt.label;
                }

                typeSelect.appendChild(o);
            });

            // Keep selection if possible and not disabled
            const validOptions = Array.from(typeSelect.options).filter(opt => !opt.disabled).map(opt => opt.value);
            if (validOptions.includes(currentValue)) {
                typeSelect.value = currentValue;
            } else if (validOptions.length > 0) {
                typeSelect.value = validOptions[0];
            }

            // Always update source value UI when type header changes
            updateSourceValueUI();
        }

        function updateSourceValueUI(preValue = null) {
            const type = document.getElementById('source_type').value;
            const isMetadataType = metadataTypes.includes(type);

            const container = document.getElementById('metadata_rules_container');
            const addBtn = document.getElementById('add-rule-btn');

            // Hide old select logic, always use text input
            sourceValueInput.style.display = 'block';
            sourceValueInput.required = true;
            sourceValueInput.disabled = false;

            const datalist = document.getElementById('source_value_datalist');

            if (isMetadataType) {
                sourceValueHelp.style.display = 'block';

                if (isServerValidated) {
                    datalist.innerHTML = '';
                    sourceValueInput.style.display = 'none';
                    sourceValueInput.required = false;
                    container.style.display = 'flex';
                    addBtn.style.display = 'inline-block';

                    if (type !== lastRenderedType || preValue) {
                        if (preValue) {
                            window._currentMetadataRules = parseMetadataValue(preValue);
                        } else {
                            window._currentMetadataRules = [{ operator: '', value: '' }];
                        }
                        lastRenderedType = type;
                    }
                    renderMetadataRules();

                    sourceValueHelp.textContent = `Select one or more ${type}s from your Jellyfin server. Use + to combine logic operators.`;
                } else {
                    datalist.innerHTML = '';
                    container.style.display = 'none';
                    addBtn.style.display = 'none';
                    sourceValueHelp.innerHTML = `You must connect your Jellyfin server to see autocompletion. You can manually type a complex filter (e.g. <code>Horror AND Action AND NOT Comedy</code>).`;
                    if (preValue) sourceValueInput.value = preValue;
                }
            } else {
                datalist.innerHTML = '';
                container.style.display = 'none';
                addBtn.style.display = 'none';
                if (preValue) sourceValueInput.value = preValue;
                if (type === 'imdb_list') {
                    sourceValueInput.placeholder = 'e.g. ls000024390 or full IMDb list URL';
                    sourceValueHelp.innerHTML = 'Enter the IMDb list ID (e.g. <code>ls000024390</code>) or paste the full URL ‚Äî the ID will be extracted automatically.';
                } else if (type === 'trakt_list') {
                    sourceValueInput.placeholder = 'https://trakt.tv/users/username/lists/list-slug';
                    sourceValueHelp.innerHTML = 'Paste the full Trakt list URL. Requires a <strong>Trakt Client ID</strong> in Server Settings. Matches by IMDb ID against your Jellyfin library.';
                } else if (type === 'tmdb_list') {
                    sourceValueInput.placeholder = 'e.g. 12345 or full TMDb list URL';
                    sourceValueHelp.innerHTML = 'Enter the TMDb list ID or paste the full URL. Matches by TMDb ID against your Jellyfin library.';
                } else if (type === 'anilist_list') {
                    sourceValueInput.placeholder = 'e.g. username  or  username/PLANNING';
                    sourceValueHelp.innerHTML = 'Enter your AniList username (e.g. <code>username</code>) or username and status (e.g. <code>username/PLANNING</code>). Matches by AniList ID against your Jellyfin library.';
                } else if (type === 'mal_list') {
                    sourceValueInput.placeholder = 'e.g. username or username/plan_to_watch';
                    sourceValueHelp.innerHTML = 'Enter your MAL username (e.g. <code>username</code>) or username and status (e.g. <code>username/plan_to_watch</code>). Matches by MAL ID against your Jellyfin library.';
                } else if (type === 'general') {
                    sourceValueInput.placeholder = 'e.g. Action  or  tt1234567';
                    sourceValueHelp.textContent = 'Enter item name or date range.';
                } else {
                    sourceValueInput.placeholder = 'e.g. Action  or  ls000024390';
                    sourceValueHelp.textContent = 'Enter the ID or Value manually.';
                }
            }
        }

        function updateValidationUI(isValid) {
            isServerValidated = isValid;

            const pathFieldIds = ['target_path', 'media_path_in_jellyfin', 'media_path_on_host'];
            const pathGroupIds = ['target_path_group', 'media_path_in_jellyfin_group', 'media_path_on_host_group'];

            const schedulerCard = document.getElementById('scheduler-card');

            if (isValid) {
                statusDot.className = 'connection-dot online';
                statusText.textContent = 'Connected';
                maintenanceCard.classList.remove('locked-section');
                groupingsSection.classList.remove('locked-section');
                if (schedulerCard) schedulerCard.classList.remove('locked-section');
                // Unlock path fields
                pathFieldIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.disabled = false;
                });
                pathGroupIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.classList.remove('path-field-locked');
                        el.querySelectorAll('button').forEach(b => b.disabled = false);
                    }
                });
            } else {
                statusDot.className = 'connection-dot offline';
                statusText.textContent = 'Disconnected';
                maintenanceCard.classList.add('locked-section');
                groupingsSection.classList.add('locked-section');
                if (schedulerCard) schedulerCard.classList.add('locked-section');
                // Lock path fields
                pathFieldIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.disabled = true;
                });
                pathGroupIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.classList.add('path-field-locked');
                        el.querySelectorAll('button').forEach(b => b.disabled = true);
                    }
                });
            }
            updateSourceTypeOptions();
        }

        function renderGroups() {
            groupsList.innerHTML = '';
            if (!currentConfig.groups || currentConfig.groups.length === 0) {
                groupsList.innerHTML = '<p style="color: var(--text-secondary); text-align: center; font-style: italic; margin-top: 2rem;">No groupings defined yet.</p>';
                updateGlobalSyncExclusionsUI();
                return;
            }

            updateGlobalSyncExclusionsUI();

            currentConfig.groups.forEach((group, index) => {
                const card = document.createElement('div');
                card.className = 'group-card';

                const catLabel = group.source_category === 'external' ? 'External' : 'Jellyfin';
                const typeLabel = sourceOptions[group.source_category]?.find(opt => opt.value === group.source_type)?.label || group.source_type;

                const sortLabels = {
                    'imdb_list_order': 'üìã IMDb List Order',
                    'trakt_list_order': 'üìã Trakt List Order',
                    'tmdb_list_order': 'üéûÔ∏è TMDb List Order',
                    'anilist_list_order': 'üé® AniList List Order',
                    'mal_list_order': 'üìã MAL List Order',
                    'CommunityRating': '‚≠ê Community Rating',
                    'ProductionYear': 'üìÖ Production Year',
                    'SortName': 'üî§ Name (A‚ÜíZ)',
                    'DateCreated': 'üïê Date Added',
                    'Random': 'üé≤ Random',
                };

                const infoDiv = document.createElement('div');
                infoDiv.className = 'group-info';

                const h4 = document.createElement('h4');
                h4.textContent = group.name || 'Unnamed Group';
                if (group.sort_order) {
                    const badge = document.createElement('span');
                    badge.setAttribute('style', 'display:inline-block; margin-left:0.5rem; font-size:0.72rem; background:rgba(99,102,241,0.15); color:var(--accent-color); border:1px solid rgba(99,102,241,0.3); border-radius:4px; padding:0.1rem 0.4rem;');
                    badge.textContent = sortLabels[group.sort_order] || group.sort_order;
                    h4.appendChild(badge);
                }
                infoDiv.appendChild(h4);

                const metaDiv = document.createElement('div');
                metaDiv.className = 'group-meta';
                const catSpan = document.createElement('span');
                catSpan.setAttribute('style', 'color: var(--accent-color); font-weight: 600;');
                catSpan.textContent = catLabel;
                metaDiv.appendChild(catSpan);
                metaDiv.appendChild(document.createTextNode(` \u2022 ${typeLabel}: ${group.source_value || ''}`));
                infoDiv.appendChild(metaDiv);
                card.appendChild(infoDiv);

                const actionsDiv = document.createElement('div');
                actionsDiv.setAttribute('style', 'display: flex; gap: 0.5rem;');

                const coverBtn = document.createElement('button');
                coverBtn.className = 'secondary-btn';
                coverBtn.title = 'Group Cover';
                coverBtn.setAttribute('style', 'padding: 0.5rem 0.8rem; font-size: 0.8rem; margin: 0; width: auto; border: 1px dashed var(--accent-color); color: var(--accent-color);');
                coverBtn.textContent = 'üé® Cover';
                coverBtn.onclick = () => openCoverGenerator(index);
                actionsDiv.appendChild(coverBtn);

                const editBtn = document.createElement('button');
                editBtn.className = 'secondary-btn';
                editBtn.title = 'Edit Group';
                editBtn.setAttribute('style', 'padding: 0.5rem 0.8rem; font-size: 0.8rem; margin: 0; width: auto; border-color: var(--accent-color); color: var(--accent-color);');
                editBtn.textContent = 'Edit';
                editBtn.onclick = () => editGroup(index);
                actionsDiv.appendChild(editBtn);

                const delBtn = document.createElement('button');
                delBtn.className = 'delete-btn';
                delBtn.title = 'Remove Group';
                delBtn.innerHTML = '<svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="margin-right: 4px;"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>';
                delBtn.appendChild(document.createTextNode(' Remove'));
                delBtn.onclick = () => deleteGroup(index);
                actionsDiv.appendChild(delBtn);

                card.appendChild(actionsDiv);
                groupsList.appendChild(card);
            });
        }

        async function saveAllConfig() {
            // Update global scheduler settings from UI before saving
            if (!currentConfig.scheduler) currentConfig.scheduler = {};
            currentConfig.scheduler.global_enabled = document.getElementById('global_scheduler_enabled').checked;
            currentConfig.scheduler.global_schedule = document.getElementById('global_sync_schedule').value.trim();
            // global_exclude_ids is updated in real-time by checkbox event listeners in updateGlobalSyncExclusionsUI

            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(currentConfig)
                });
                if (response.ok) {
                    showStatus('Settings saved', 'success');
                    renderGroups();
                    updateSourceTypeOptions();
                } else {
                    showStatus('Server error while saving', 'error');
                }
            } catch (err) {
                showStatus('Network error - changes not saved locally', 'error');
            }
        }

        function showStatus(msg, type) {
            statusMsg.textContent = msg;
            statusMsg.className = `status-msg ${type}`;
            statusMsg.style.display = 'block';
            setTimeout(() => { if (statusMsg.textContent === msg) statusMsg.style.display = 'none'; }, 3000);
        }

        configForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            saveBtn.classList.add('btn-loading');

            currentConfig.jellyfin_url = document.getElementById('jellyfin_url').value;
            currentConfig.api_key = document.getElementById('api_key').value;
            currentConfig.target_path = document.getElementById('target_path').value;
            currentConfig.media_path_in_jellyfin = document.getElementById('media_path_in_jellyfin').value;
            currentConfig.media_path_on_host = document.getElementById('media_path_on_host').value;

            await saveAllConfig();
            saveBtn.classList.remove('btn-loading');

            // Re-trigger metadata discovery after settings change
            await refreshMetadata();
        });

        apiConfigForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            saveApisBtn.classList.add('btn-loading');

            currentConfig.trakt_client_id = document.getElementById('trakt_client_id').value;
            currentConfig.tmdb_api_key = document.getElementById('tmdb_api_key').value;
            currentConfig.mal_client_id = document.getElementById('mal_client_id').value;

            await saveAllConfig();
            saveApisBtn.classList.remove('btn-loading');
        });

        groupForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const source_type = document.getElementById('source_type').value;
            const val = getFilterValue();

            if (!val) {
                showStatus('Please enter or select a filter value', 'error');
                return;
            }

            const groupData = {
                name: document.getElementById('group_name').value,
                source_category: document.getElementById('source_category').value,
                source_type: source_type,
                source_value: val,
                sort_order: document.getElementById('sort_order_enabled').checked ? (document.getElementById('sort_order').value || '') : '',
                schedule_enabled: document.getElementById('schedule_enabled').checked,
                schedule: document.getElementById('group_schedule').value.trim()
            };

            if (metadataTypes.includes(source_type)) {
                if (typeof window._currentMetadataRules !== 'undefined' && Array.isArray(window._currentMetadataRules)) {
                    const validRules = window._currentMetadataRules.filter(r => r.value && r.value.trim() !== '');
                    if (validRules.length > 0) {
                        groupData.rules = validRules.map(r => ({
                            operator: r.operator || 'AND',
                            type: r.type || (source_type === 'complex' ? 'genre' : source_type),
                            value: r.value
                        }));
                    }
                }
            }

            if (!currentConfig.groups) currentConfig.groups = [];

            if (editingIndex >= 0) {
                currentConfig.groups[editingIndex] = groupData;
                editingIndex = -1;
            } else {
                currentConfig.groups.push(groupData);
            }

            await saveAllConfig();
            groupForm.reset();
            resetFormUI();
        });

        function editGroup(index) {
            editingIndex = index;
            const group = currentConfig.groups[index];

            document.getElementById('group_name').value = group.name;
            document.getElementById('source_category').value = group.source_category || 'jellyfin';
            updateSourceTypeOptions();
            document.getElementById('source_type').value = group.source_type;
            const hasSortOrder = !!(group.sort_order);
            document.getElementById('sort_order_enabled').checked = hasSortOrder;
            document.getElementById('sort_order_panel').style.display = hasSortOrder ? 'block' : 'none';
            document.getElementById('sort_order').value = group.sort_order || '';

            const hasSchedule = !!(group.schedule_enabled);
            document.getElementById('schedule_enabled').checked = hasSchedule;
            document.getElementById('group_scheduler_panel').style.display = hasSchedule ? 'block' : 'none';
            document.getElementById('group_schedule').value = group.schedule || '';

            updateSourceValueUI(group.source_value);

            groupFormTitle.textContent = 'Edit Grouping';
            addGroupBtn.textContent = 'Update Grouping';
            cancelEditBtn.style.display = 'block';

            // Scroll form into view
            groupForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function cancelEdit() {
            editingIndex = -1;
            groupForm.reset();
            resetFormUI();
        }

        function resetFormUI() {
            groupFormTitle.textContent = 'Create New Grouping';
            addGroupBtn.textContent = 'Add Grouping';
            cancelEditBtn.style.display = 'none';
            document.getElementById('sort_order_enabled').checked = false;
            document.getElementById('sort_order_panel').style.display = 'none';
            document.getElementById('schedule_enabled').checked = false;
            document.getElementById('group_scheduler_panel').style.display = 'none';
            updateSourceTypeOptions();
        }

        function toggleSortOrder(checkbox) {
            document.getElementById('sort_order_panel').style.display = checkbox.checked ? 'block' : 'none';
        }

        // --- Cover Generator Logic ---
        let activeCoverIndex = -1;

        function openCoverGenerator(index) {
            activeCoverIndex = index;
            const group = currentConfig.groups[index];

            document.getElementById('cover-text').value = group.cover_text || group.name || 'Custom Group';
            document.getElementById('cover-theme').value = group.cover_theme || 'modern-dark';
            document.getElementById('cover-border-style').value = group.cover_border_style || 'none';
            document.getElementById('cover-border-color').value = group.cover_border_color || '#ffffff';
            document.getElementById('cover-color-1').value = group.cover_color1 || '#4f46e5';
            document.getElementById('cover-color-2').value = group.cover_color2 || '#9333ea';

            document.getElementById('cover-generator-modal').style.display = 'flex';

            // Ensure fonts are ready before first render
            if (document.fonts && document.fonts.ready) {
                document.fonts.ready.then(() => renderCover());
            } else {
                setTimeout(() => renderCover(), 100);
            }
        }

        // --- Deterministic PRNG helpers ---
        function mulberry32(a) {
            return function () {
                let t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        function getSeed(str) {
            let hash = 2166136261;
            for (let i = 0; i < str.length; i++) {
                hash ^= str.charCodeAt(i);
                hash = Math.imul(hash, 16777619);
            }
            return hash >>> 0;
        }

        function renderCover() {
            const canvas = document.getElementById('cover-canvas');
            const ctx = canvas.getContext('2d');
            const text = document.getElementById('cover-text').value.trim() || 'Group Name';
            const theme = document.getElementById('cover-theme').value;
            const color1 = document.getElementById('cover-color-1').value;
            const color2 = document.getElementById('cover-color-2').value;

            // Seeded random for deterministic renders
            const seed = getSeed(text + theme + color1 + color2);
            const seededRand = mulberry32(seed);

            // High-DPI Anti-Aliasing Fix
            const dpr = window.devicePixelRatio || 1;
            const logicalW = 1920;
            const logicalH = 1080;

            if (canvas.width !== logicalW * dpr) {
                canvas.width = logicalW * dpr;
                canvas.height = logicalH * dpr;
                canvas.style.width = logicalW + 'px';
                canvas.style.height = logicalH + 'px';
            }

            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            const w = logicalW;
            const h = logicalH;

            ctx.clearRect(0, 0, w, h);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            const helpers = {
                hexToRgb: (hex) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? {
                        r: parseInt(result[1], 16),
                        g: parseInt(result[2], 16),
                        b: parseInt(result[3], 16)
                    } : { r: 0, g: 0, b: 0 };
                },
                roundRect: roundRect,
                wrapText: wrapText,
                seededRand: seededRand
            };

            const themeFunctions = {
                'modern-dark': (ctx, w, h, { color1, color2 }, hlp) => {
                    const grad = ctx.createLinearGradient(0, 0, w, h);
                    grad.addColorStop(0, '#1a1a24');
                    grad.addColorStop(1, '#0b0b10');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    const rgb1 = hlp.hexToRgb(color1);
                    const rgb2 = hlp.hexToRgb(color2);

                    const blob1 = ctx.createRadialGradient(w / 4, h / 2, 0, w / 4, h / 2, 800);
                    blob1.addColorStop(0, `rgba(${rgb1.r}, ${rgb1.g}, ${rgb1.b}, 0.2)`);
                    blob1.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = blob1;
                    ctx.fillRect(0, 0, w, h);

                    const blob2 = ctx.createRadialGradient(w * 0.75, h / 2, 0, w * 0.75, h / 2, 800);
                    blob2.addColorStop(0, `rgba(${rgb2.r}, ${rgb2.g}, ${rgb2.b}, 0.2)`);
                    blob2.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = blob2;
                    ctx.fillRect(0, 0, w, h);
                },
                'vibrant-glow': (ctx, w, h, { color1, color2 }, hlp) => {
                    const grad = ctx.createLinearGradient(0, 0, w, h);
                    grad.addColorStop(0, color1);
                    grad.addColorStop(1, color2);
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    const rgb1 = hlp.hexToRgb(color1);
                    const rgb2 = hlp.hexToRgb(color2);

                    ctx.globalAlpha = 0.6;
                    const glow1 = ctx.createRadialGradient(w * 0.3, h * 0.3, 0, w * 0.3, h * 0.3, w * 0.8);
                    glow1.addColorStop(0, `rgba(${rgb1.r}, ${rgb1.g}, ${rgb1.b}, 1)`);
                    glow1.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = glow1;
                    ctx.fillRect(0, 0, w, h);

                    const glow2 = ctx.createRadialGradient(w * 0.7, h * 0.7, 0, w * 0.7, h * 0.7, w * 0.8);
                    glow2.addColorStop(0, `rgba(${rgb2.r}, ${rgb2.g}, ${rgb2.b}, 1)`);
                    glow2.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = glow2;
                    ctx.fillRect(0, 0, w, h);

                    // Seeded noise/grain
                    ctx.globalAlpha = 0.04;
                    for (let i = 0; i < 4000; i++) {
                        ctx.fillStyle = i % 2 === 0 ? '#ffffff' : '#000000';
                        ctx.fillRect(hlp.seededRand() * w, hlp.seededRand() * h, 2, 2);
                    }
                    ctx.globalAlpha = 1.0;
                    ctx.filter = 'none';
                },
                'minimal-glass': (ctx, w, h, { color1, color2 }, hlp) => {
                    ctx.fillStyle = '#f8fafc';
                    ctx.fillRect(0, 0, w, h);

                    ctx.fillStyle = color1;
                    ctx.beginPath(); ctx.arc(w - 200, 250, 400, 0, Math.PI * 2); ctx.fill();

                    ctx.fillStyle = color2;
                    ctx.beginPath(); ctx.arc(300, h - 300, 500, 0, Math.PI * 2); ctx.fill();

                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                    ctx.fillRect(100, 100, w - 200, h - 200);
                    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(100, 100, w - 200, h - 200);
                },
                'cyberpunk': (ctx, w, h, { color1, color2 }, hlp) => {
                    ctx.fillStyle = '#050505';
                    ctx.fillRect(0, 0, w, h);

                    const rgb1 = hlp.hexToRgb(color1);
                    const rgb2 = hlp.hexToRgb(color2);

                    const g1 = ctx.createRadialGradient(w * 0.2, h * 0.3, 0, w * 0.2, h * 0.3, 600);
                    g1.addColorStop(0, `rgba(${rgb1.r}, ${rgb1.g}, ${rgb1.b}, 0.3)`);
                    g1.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = g1;
                    ctx.fillRect(0, 0, w, h);

                    const g2 = ctx.createRadialGradient(w * 0.8, h * 0.7, 0, w * 0.8, h * 0.7, 800);
                    g2.addColorStop(0, `rgba(${rgb2.r}, ${rgb2.g}, ${rgb2.b}, 0.25)`);
                    g2.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = g2;
                    ctx.fillRect(0, 0, w, h);

                    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < h; i += 4) {
                        ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(w, i); ctx.stroke();
                    }

                    ctx.fillStyle = color1;
                    ctx.globalAlpha = 0.2;
                    for (let i = 0; i < 5; i++) {
                        const gx = hlp.seededRand() * w;
                        const gy = hlp.seededRand() * h;
                        ctx.fillRect(gx, gy, hlp.seededRand() * 200, 2);
                    }
                    ctx.fillStyle = color2;
                    for (let i = 0; i < 5; i++) {
                        const gx = hlp.seededRand() * w;
                        const gy = hlp.seededRand() * h;
                        ctx.fillRect(gx, gy, hlp.seededRand() * 150, 1);
                    }
                    ctx.globalAlpha = 1.0;
                },
                'aurora': (ctx, w, h, { color1, color2 }, hlp) => {
                    ctx.fillStyle = '#0a0a1a';
                    ctx.fillRect(0, 0, w, h);

                    ctx.filter = 'blur(120px)';
                    ctx.globalAlpha = 0.4;

                    ctx.fillStyle = color1;
                    ctx.beginPath();
                    ctx.moveTo(-100, h * 0.5);
                    ctx.bezierCurveTo(w * 0.25, h * 0.2, w * 0.75, h * 0.8, w + 100, h * 0.4);
                    ctx.lineTo(w + 100, h * 0.6);
                    ctx.bezierCurveTo(w * 0.75, h * 0.9, w * 0.25, h * 0.3, -100, h * 0.7);
                    ctx.fill();

                    ctx.fillStyle = color2;
                    ctx.beginPath();
                    ctx.moveTo(-100, h * 0.2);
                    ctx.bezierCurveTo(w * 0.3, h * 0.5, w * 0.7, h * 0.1, w + 100, h * 0.3);
                    ctx.lineTo(w + 100, h * 0.4);
                    ctx.bezierCurveTo(w * 0.7, h * 0.2, w * 0.3, h * 0.6, -100, h * 0.3);
                    ctx.fill();

                    ctx.filter = 'none';
                    ctx.globalAlpha = 1.0;
                },
                'monochrome': (ctx, w, h, { color1, color2 }, hlp) => {
                    ctx.fillStyle = '#111827';
                    ctx.fillRect(0, 0, w, h);

                    ctx.fillStyle = color1;
                    ctx.globalAlpha = 0.1;
                    for (let i = 0; i < 8; i++) {
                        ctx.beginPath();
                        ctx.moveTo(hlp.seededRand() * w, hlp.seededRand() * h);
                        ctx.lineTo(hlp.seededRand() * w, hlp.seededRand() * h);
                        ctx.lineTo(hlp.seededRand() * w, hlp.seededRand() * h);
                        ctx.fill();
                    }

                    ctx.fillStyle = color2;
                    ctx.globalAlpha = 0.05;
                    for (let i = 0; i < 12; i++) {
                        ctx.beginPath();
                        ctx.moveTo(hlp.seededRand() * w, hlp.seededRand() * h);
                        ctx.lineTo(hlp.seededRand() * w, hlp.seededRand() * h);
                        ctx.lineTo(hlp.seededRand() * w, hlp.seededRand() * h);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1.0;
                },
                'vintage': (ctx, w, h, { color1 }, hlp) => {
                    ctx.fillStyle = '#fdf4ff';
                    ctx.fillRect(0, 0, w, h);

                    ctx.fillStyle = color1;
                    ctx.globalAlpha = 0.15;
                    ctx.fillRect(0, 0, w, h);

                    const vig = ctx.createRadialGradient(w / 2, h / 2, w / 4, w / 2, h / 2, w);
                    vig.addColorStop(0, 'rgba(0,0,0,0)');
                    vig.addColorStop(1, 'rgba(0,0,0,0.6)');
                    ctx.fillStyle = vig;
                    ctx.globalAlpha = 1.0;
                    ctx.fillRect(0, 0, w, h);

                    ctx.fillStyle = '#000000';
                    ctx.globalAlpha = 0.05;
                    for (let i = 0; i < 2000; i++) {
                        ctx.fillRect(hlp.seededRand() * w, hlp.seededRand() * h, 1, 1);
                    }
                    ctx.globalAlpha = 1.0;
                }
            };

            if (themeFunctions[theme]) {
                themeFunctions[theme](ctx, w, h, { color1, color2 }, helpers);
            }

            // Reset state after theme drawing
            ctx.filter = 'none';
            ctx.globalAlpha = 1.0;
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';

            // --- Independent Border Drawing ---
            const borderStyle = document.getElementById('cover-border-style').value;
            const borderColor = document.getElementById('cover-border-color').value;

            if (borderStyle !== 'none') {
                if (borderStyle === 'elegant') {
                    const m = 40;
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 12; ctx.globalAlpha = 0.15;
                    roundRect(ctx, m, m, w - m * 2, h - m * 2, 20); ctx.stroke();
                    ctx.lineWidth = 2; ctx.globalAlpha = 0.9;
                    roundRect(ctx, m + 4, m + 4, w - (m + 4) * 2, h - (m + 4) * 2, 16); ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }
                else if (borderStyle === 'bold-frame') {
                    const m = 45;
                    ctx.shadowColor = 'rgba(0,0,0,0.6)'; ctx.shadowBlur = 30; ctx.shadowOffsetY = 15;
                    ctx.strokeStyle = borderColor; ctx.lineWidth = 30;
                    roundRect(ctx, m, m, w - m * 2, h - m * 2, 35); ctx.stroke();
                    ctx.shadowColor = 'transparent';
                    ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 4;
                    const im = m + 13; roundRect(ctx, im, im, w - im * 2, h - im * 2, 22); ctx.stroke();
                    ctx.strokeStyle = 'rgba(0,0,0,0.4)'; ctx.lineWidth = 4;
                    const om = m - 13; roundRect(ctx, om, om, w - om * 2, h - om * 2, 48); ctx.stroke();
                }
                else if (borderStyle === 'neon-glow') {
                    const m = 55;
                    ctx.shadowColor = borderColor; ctx.shadowBlur = 80;
                    ctx.strokeStyle = borderColor; ctx.lineWidth = 15; ctx.globalAlpha = 0.4;
                    roundRect(ctx, m, m, w - m * 2, h - m * 2, 30); ctx.stroke();
                    ctx.shadowBlur = 20; ctx.lineWidth = 8; ctx.globalAlpha = 0.8;
                    roundRect(ctx, m, m, w - m * 2, h - m * 2, 30); ctx.stroke();
                    ctx.shadowColor = 'transparent'; ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 4; ctx.globalAlpha = 1.0;
                    roundRect(ctx, m, m, w - m * 2, h - m * 2, 30); ctx.stroke();
                }
                else if (borderStyle === 'tech-corners') {
                    const m = 50; const len = 140; const chamfer = 25;
                    ctx.strokeStyle = borderColor; ctx.lineWidth = 8; ctx.lineJoin = 'miter';
                    ctx.beginPath();
                    ctx.moveTo(m, m + len); ctx.lineTo(m, m + chamfer); ctx.lineTo(m + chamfer, m); ctx.lineTo(m + len, m);
                    ctx.moveTo(w - m - len, m); ctx.lineTo(w - m - chamfer, m); ctx.lineTo(w - m, m + chamfer); ctx.lineTo(w - m, m + len);
                    ctx.moveTo(w - m, h - m - len); ctx.lineTo(w - m, h - m - chamfer); ctx.lineTo(w - m - chamfer, h - m); ctx.lineTo(w - m - len, h - m);
                    ctx.moveTo(m + len, h - m); ctx.lineTo(m + chamfer, h - m); ctx.lineTo(m, h - m - chamfer); ctx.lineTo(m, h - m - len);
                    ctx.stroke();
                    ctx.lineWidth = 2; ctx.globalAlpha = 0.5; const im = m + 18;
                    ctx.beginPath();
                    ctx.moveTo(im, im + len - 20); ctx.lineTo(im, im); ctx.lineTo(im + len - 20, im);
                    ctx.moveTo(w - im - len + 20, im); ctx.lineTo(w - im, im); ctx.lineTo(w - im, im + len - 20);
                    ctx.moveTo(w - im, h - im - len + 20); ctx.lineTo(w - im, h - im); ctx.lineTo(w - im - len + 20, h - im);
                    ctx.moveTo(im + len - 20, h - im); ctx.lineTo(im, h - im); ctx.lineTo(im, h - im - len + 20);
                    ctx.stroke(); ctx.globalAlpha = 1.0;
                    ctx.fillStyle = borderColor; const blockOffset = m + len + 15;
                    ctx.fillRect(blockOffset, m - 4, 30, 8); ctx.fillRect(blockOffset + 40, m - 4, 10, 8);
                    ctx.fillRect(w - blockOffset - 30, m - 4, 30, 8);
                    ctx.fillRect(blockOffset, h - m - 4, 40, 8); ctx.fillRect(w - blockOffset - 20, h - m - 4, 20, 8);
                    ctx.fillRect(w - blockOffset - 40, h - m - 4, 10, 8);
                }
                else if (borderStyle === 'double-inset') {
                    const m1 = 40; const m2 = 55; ctx.strokeStyle = borderColor; ctx.lineWidth = 2;
                    roundRect(ctx, m1, m1, w - m1 * 2, h - m1 * 2, 20); ctx.stroke();
                    roundRect(ctx, m2, m2, w - m2 * 2, h - m2 * 2, 10); ctx.stroke();
                }
                else if (borderStyle === 'corner-brackets') {
                    const m = 40; const len = 100; ctx.strokeStyle = borderColor; ctx.lineWidth = 12; ctx.lineCap = 'square';
                    ctx.beginPath(); ctx.moveTo(m, m + len); ctx.lineTo(m, m); ctx.lineTo(m + len, m); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(w - m - len, m); ctx.lineTo(w - m, m); ctx.lineTo(w - m, m + len); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(w - m, h - m - len); ctx.lineTo(w - m, h - m); ctx.lineTo(w - m - len, h - m); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(m + len, h - m); ctx.lineTo(m, h - m); ctx.lineTo(m, h - m - len); ctx.stroke();
                }
                else if (borderStyle === 'industrial-dash') {
                    const m = 50; ctx.strokeStyle = borderColor; ctx.lineWidth = 8; ctx.setLineDash([40, 20]);
                    roundRect(ctx, m, m, w - m * 2, h - m * 2, 20); ctx.stroke(); ctx.setLineDash([]);
                }
                else if (borderStyle === 'ornate') {
                    const m = 60; ctx.strokeStyle = borderColor; ctx.lineWidth = 4;
                    roundRect(ctx, m, m, w - m * 2, h - m * 2, 30); ctx.stroke();
                    const r = 15; ctx.fillStyle = borderColor;
                    ctx.beginPath(); ctx.arc(w / 2, m, r, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(w / 2, h - m, r, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(m, h / 2, r, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(w - m, h / 2, r, 0, Math.PI * 2); ctx.fill();
                }
            }

            // Reset state before text drawing
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.globalAlpha = 1.0;
            ctx.filter = 'none';

            // --- Draw Text ---
            if (theme === 'modern-dark') {
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 120px "Outfit", sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                wrapText(ctx, text, w / 2, h / 2 + 50, w - 200, 140);
            }
            else if (theme === 'vibrant-glow') {
                ctx.fillStyle = '#ffffff';
                ctx.font = '800 140px "Outfit", sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 30;
                wrapText(ctx, text, w / 2, h / 2, w - 200, 160);
            }
            else if (theme === 'minimal-glass') {
                ctx.fillStyle = '#0f172a';
                ctx.font = '600 130px "Outfit", sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                wrapText(ctx, text, w / 2, h / 2, w - 300, 150);
            }
            else if (theme === 'cyberpunk') {
                ctx.fillStyle = '#ffffff';
                ctx.font = '900 150px "Outfit", sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.shadowColor = color1; ctx.shadowBlur = 20;
                wrapText(ctx, text, w / 2, h / 2, w - 200, 170);
            }
            else if (theme === 'aurora') {
                ctx.fillStyle = '#ffffff';
                ctx.font = '300 140px "Outfit", sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.filter = 'blur(1px)';
                wrapText(ctx, text, w / 2, h / 2, w - 300, 160);
            }
            else if (theme === 'monochrome') {
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 160px "Outfit", sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                wrapText(ctx, text, w / 2, h / 2, w - 200, 180);
            }
            else if (theme === 'vintage') {
                ctx.fillStyle = '#422006';
                ctx.font = 'italic 500 120px "Outfit", sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.globalAlpha = 0.8;
                wrapText(ctx, text, w / 2, h / 2, w - 300, 140);
            }

            // Final state reset
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.globalAlpha = 1.0;
            ctx.filter = 'none';
        }

        // Helper to draw rounded rectangles on canvas natively
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let lines = [];
            for (let n = 0; n < words.length; n++) {
                let word = words[n];
                let testLine = line + word + ' ';
                let metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth) {
                    if (line !== '') {
                        lines.push(line);
                        line = '';
                        testLine = word + ' ';
                        metrics = ctx.measureText(testLine);
                    }
                    if (metrics.width > maxWidth) {
                        let chars = word.split('');
                        let segment = '';
                        for (let c = 0; c < chars.length; c++) {
                            let testSegment = segment + chars[c];
                            if (ctx.measureText(testSegment).width > maxWidth && segment !== '') {
                                lines.push(segment);
                                segment = chars[c];
                            } else {
                                segment = testSegment;
                            }
                        }
                        line = segment + ' ';
                    } else {
                        line = word + ' ';
                    }
                } else {
                    line = testLine;
                }
            }
            lines.push(line);

            let startY = y - ((lines.length - 1) * lineHeight) / 2;
            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i].trim(), x, startY + (i * lineHeight));
            }
        }

        async function applyCover() {
            if (activeCoverIndex < 0) return;
            const group = currentConfig.groups[activeCoverIndex];

            const canvas = document.getElementById('cover-canvas');
            const dataUrl = canvas.toDataURL('image/jpeg', 0.92);

            try {
                const response = await fetch('/api/upload_cover', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ group_name: group.name, image: dataUrl })
                });

                if (response.ok) {
                    showStatus('Cover generated and saved!', 'success');

                    // Save explicit aesthetic config directly back to the group
                    group.cover_text = document.getElementById('cover-text').value;
                    group.cover_theme = document.getElementById('cover-theme').value;
                    group.cover_border_style = document.getElementById('cover-border-style').value;
                    group.cover_border_color = document.getElementById('cover-border-color').value;
                    group.cover_color1 = document.getElementById('cover-color-1').value;
                    group.cover_color2 = document.getElementById('cover-color-2').value;

                    await saveAllConfig();
                    closeModal('cover-generator-modal');
                } else {
                    showStatus('Failed to upload cover image.', 'error');
                }
            } catch (err) {
                showStatus('Network error while saving cover.', 'error');
            }
        }

        async function deleteGroup(index) {
            if (confirm('Permanently remove this grouping?')) {
                if (editingIndex === index) cancelEdit();
                currentConfig.groups.splice(index, 1);
                await saveAllConfig();
            }
        }

        async function clearAllGroups() {
            if (confirm('Are you sure you want to remove ALL groupings? This cannot be undone.')) {
                currentConfig.groups = [];
                await saveAllConfig();
            }
        }

        // --- Streamlined Import / Export Logic ---

        function openExportModal() {
            const container = document.getElementById('export-groups-container');
            container.innerHTML = '';

            if (currentConfig.groups.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9rem;">No groups available to export.</p>';
            } else {
                currentConfig.groups.forEach((g, i) => {
                    const item = document.createElement('div');
                    item.className = 'modal-item';

                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.checked = true;
                    cb.className = 'export-check';
                    cb.dataset.index = i;
                    cb.setAttribute('style', 'width:18px; height:18px; accent-color: var(--accent-color);');
                    item.appendChild(cb);

                    const labelDiv = document.createElement('div');
                    const nameDiv = document.createElement('div');
                    nameDiv.setAttribute('style', 'font-weight:600; font-size:0.95rem;');
                    nameDiv.textContent = g.name || 'Unnamed Group';
                    const typeDiv = document.createElement('div');
                    typeDiv.setAttribute('style', 'font-size:0.8rem; color:var(--text-secondary);');
                    typeDiv.textContent = g.source_type || '';
                    labelDiv.appendChild(nameDiv);
                    labelDiv.appendChild(typeDiv);
                    item.appendChild(labelDiv);

                    container.appendChild(item);
                });
            }

            document.querySelector('input[name="export-type"][value="all"]').checked = true;
            toggleExportSelection();
            document.getElementById('export-modal').style.display = 'flex';
        }

        function toggleExportSelection() {
            const type = document.querySelector('input[name="export-type"]:checked').value;
            document.getElementById('export-selection-list').style.display = (type === 'selective') ? 'block' : 'none';
        }

        function execExport() {
            const type = document.querySelector('input[name="export-type"]:checked').value;
            let dataToExport = {};
            let filename = 'jellyfin-groupings-export.json';

            if (type === 'all') {
                dataToExport = currentConfig;
                filename = 'jellyfin-config-full.json';
            } else {
                const selectedIndices = Array.from(document.querySelectorAll('.export-check:checked'))
                    .map(cb => parseInt(cb.dataset.index));

                if (selectedIndices.length === 0) {
                    alert('Please select at least one grouping.');
                    return;
                }
                dataToExport = { groups: selectedIndices.map(i => currentConfig.groups[i]) };
                filename = 'jellyfin-selected-groupings.json';
            }

            downloadJSON(dataToExport, filename);
            closeModal('export-modal');
        }

        function openImportModal() {
            document.getElementById('import-step-1').style.display = 'block';
            document.getElementById('import-step-2').style.display = 'none';
            document.getElementById('cancel-import-top').style.display = 'block';
            document.getElementById('import-modal').style.display = 'flex';
        }

        function handleFileSelected(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    pendingImportData = data;
                    setupImportStep2(data);
                } catch (err) {
                    showStatus('Invalid JSON file', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset
        }

        function setupImportStep2(data) {
            document.getElementById('import-step-1').style.display = 'none';
            document.getElementById('import-step-2').style.display = 'block';
            document.getElementById('cancel-import-top').style.display = 'none';

            const warning = document.getElementById('import-warning');
            const selectionList = document.getElementById('import-selection-list');
            const container = document.getElementById('import-groups-container');
            const confirmBtn = document.getElementById('confirm-import');

            container.innerHTML = '';

            // Detection: Is it a full config or just groups?
            const isFullConfig = data.jellyfin_url !== undefined && data.api_key !== undefined;
            const groups = data.groups || (Array.isArray(data) ? data : null);

            if (isFullConfig) {
                warning.style.display = 'block';
                selectionList.style.display = 'none';
                confirmBtn.textContent = 'Overwrite All';
                confirmBtn.onclick = () => performImport('full');
            } else if (groups) {
                warning.style.display = 'none';
                selectionList.style.display = 'block';
                confirmBtn.textContent = 'Import Selected';

                groups.forEach((g, i) => {
                    const item = document.createElement('div');
                    item.className = 'modal-item';

                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.checked = true;
                    cb.className = 'import-check';
                    cb.dataset.index = i;
                    cb.setAttribute('style', 'width:18px; height:18px; accent-color: var(--accent-color);');
                    item.appendChild(cb);

                    const labelDiv = document.createElement('div');
                    const nameDiv = document.createElement('div');
                    nameDiv.setAttribute('style', 'font-weight:600; font-size:0.95rem;');
                    nameDiv.textContent = g.name || 'Unnamed Group';
                    const typeDiv = document.createElement('div');
                    typeDiv.setAttribute('style', 'font-size:0.8rem; color:var(--text-secondary);');
                    typeDiv.textContent = `${g.source_type || ''}: ${g.source_value || ''}`;
                    labelDiv.appendChild(nameDiv);
                    labelDiv.appendChild(typeDiv);
                    item.appendChild(labelDiv);

                    container.appendChild(item);
                });
                confirmBtn.onclick = () => performImport('groups', groups);
            } else {
                showStatus('Incompatible file structure', 'error');
                closeModal('import-modal');
            }
        }

        async function performImport(type, sourceGroups = null) {
            if (type === 'full') {
                currentConfig = pendingImportData;
            } else {
                const selectedIndices = Array.from(document.querySelectorAll('.import-check:checked'))
                    .map(cb => parseInt(cb.dataset.index));

                const toImport = selectedIndices.map(i => sourceGroups[i]);
                currentConfig.groups = [...currentConfig.groups, ...toImport];
            }

            await saveAllConfig();
            closeModal('import-modal');
            showStatus('Import successful!', 'success');
            loadConfig();
        }

        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 4)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function closeModal(id) {
            document.getElementById(id).style.display = 'none';
            pendingImportData = null;
        }

        async function autoDetectPaths() {
            const detectBtn = document.getElementById('auto-detect-btn');
            detectBtn.classList.add('btn-loading');
            try {
                const result = await fetchAutoDetect();
                if (result.status === 'success' && result.detected.media_path_on_host) {
                    document.getElementById('media_path_in_jellyfin').value = result.detected.media_path_in_jellyfin;
                    document.getElementById('media_path_on_host').value = result.detected.media_path_on_host;
                    document.getElementById('target_path').value = result.detected.target_path;
                    currentConfig.media_path_in_jellyfin = result.detected.media_path_in_jellyfin;
                    currentConfig.media_path_on_host = result.detected.media_path_on_host;
                    currentConfig.target_path = result.detected.target_path;
                    showStatus('Paths auto-detected! Remember to Save.', 'success');
                } else if (result.status === 'success') {
                    showStatus('Auto-detection finished but could not find matching host paths. You may need to set them manually.', 'error');
                } else {
                    showStatus(result.message || 'Auto-detection failed', 'error');
                }
            } catch (err) {
                showStatus('Auto-detection failed - API unreachable', 'error');
            } finally {
                detectBtn.classList.remove('btn-loading');
            }
        }

        async function fetchAutoDetect() {
            const resp = await fetch('/api/jellyfin/auto-detect-paths', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            return resp.json();
        }

        /** Called silently after a successful test; fills only empty path fields. */
        async function autoDetectIfEmpty() {
            const targetEl = document.getElementById('target_path');
            const jfEl = document.getElementById('media_path_in_jellyfin');
            const hostEl = document.getElementById('media_path_on_host');
            if (targetEl.value && jfEl.value && hostEl.value) return;
            try {
                const result = await fetchAutoDetect();
                if (result.status !== 'success') return;
                const d = result.detected;
                if (!targetEl.value && d.target_path) { targetEl.value = d.target_path; currentConfig.target_path = d.target_path; }
                if (!jfEl.value && d.media_path_in_jellyfin) { jfEl.value = d.media_path_in_jellyfin; currentConfig.media_path_in_jellyfin = d.media_path_in_jellyfin; }
                if (!hostEl.value && d.media_path_on_host) { hostEl.value = d.media_path_on_host; currentConfig.media_path_on_host = d.media_path_on_host; }
                showStatus('Paths auto-filled ‚Äî review and save.', 'success');
            } catch (_) { /* silently ignore */ }
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Folder Picker
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let _pickerTargetId = null;
        let _pickerCurrentPath = null;

        async function openPathPicker(fieldId) {
            _pickerTargetId = fieldId;
            const currentVal = document.getElementById(fieldId).value;
            document.getElementById('picker-title').textContent =
                fieldId === 'target_path' ? 'Select Target Path' :
                    fieldId === 'media_path_in_jellyfin' ? 'Select Media Path (Jellyfin side)' :
                        'Select Media Path (this machine)';
            document.getElementById('path-picker-modal').style.display = 'flex';
            await browseDir(currentVal || '');
        }

        async function browseDir(path) {
            document.getElementById('picker-body').innerHTML =
                '<p style="padding:1.5rem; text-align:center; color:var(--text-secondary);">Loading‚Ä¶</p>';
            let result;
            try {
                const resp = await fetch('/api/browse?path=' + encodeURIComponent(path));
                result = await resp.json();
            } catch (e) {
                const errP = document.createElement('p');
                errP.className = 'picker-empty';
                errP.textContent = `Could not load directory: ${e.message}`;
                document.getElementById('picker-body').appendChild(errP);
                return;
            }
            if (result.status !== 'success') {
                const errP = document.createElement('p');
                errP.className = 'picker-empty';
                errP.textContent = result.message;
                document.getElementById('picker-body').appendChild(errP);
                return;
            }
            _pickerCurrentPath = result.current;
            document.getElementById('picker-breadcrumb').textContent = result.current;
            document.getElementById('picker-footer-path').textContent = result.current;

            const body = document.getElementById('picker-body');
            body.innerHTML = '';

            if (result.parent) {
                const up = document.createElement('button');
                up.className = 'picker-item picker-up';
                up.innerHTML = '<span class="picker-item-icon">‚¨ÜÔ∏è</span> .. (go up)';
                up.onclick = () => browseDir(result.parent);
                body.appendChild(up);
            }

            if (result.dirs.length === 0) {
                const empty = document.createElement('p');
                empty.className = 'picker-empty';
                empty.textContent = 'No subdirectories here.';
                body.appendChild(empty);
            } else {
                result.dirs.forEach(name => {
                    const btn = document.createElement('button');
                    btn.className = 'picker-item';
                    const fullPath = result.current.replace(/\/$/, '') + '/' + name;
                    const icon = document.createElement('span');
                    icon.className = 'picker-item-icon';
                    icon.textContent = 'üìÅ';
                    btn.appendChild(icon);
                    btn.appendChild(document.createTextNode(' ' + name));
                    btn.title = fullPath;
                    btn.onclick = () => browseDir(fullPath);
                    body.appendChild(btn);
                });
            }
        }

        function confirmPicker() {
            if (_pickerTargetId && _pickerCurrentPath) {
                document.getElementById(_pickerTargetId).value = _pickerCurrentPath;
            }
            closePicker();
        }

        function closePicker() {
            document.getElementById('path-picker-modal').style.display = 'none';
            _pickerTargetId = null;
        }

        function pickerOutsideClick(e) {
            if (e.target === document.getElementById('path-picker-modal')) closePicker();
        }

        async function openCleanupModal() {
            document.getElementById('cleanup-modal').style.display = 'flex';
            document.getElementById('cleanup-loading').style.display = 'flex';
            document.getElementById('cleanup-content').style.display = 'none';
            document.getElementById('cleanup-error').style.display = 'none';

            try {
                const response = await fetch('/api/cleanup');
                const result = await response.json();

                if (result.status === 'success') {
                    const listContainer = document.getElementById('cleanup-list');
                    listContainer.innerHTML = '';

                    if (!result.items || result.items.length === 0) {
                        listContainer.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-secondary); font-style: italic;">No folders found in Target Directory.</div>';
                    } else {
                        result.items.forEach(item => {
                            const row = document.createElement('label');
                            row.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 0.8rem; border-bottom: 1px solid var(--glass-border); cursor: pointer; transition: background 0.15s; text-transform: none; font-weight: 400;';
                            row.onmouseover = () => row.style.background = 'rgba(255,255,255,0.05)';
                            row.onmouseout = () => row.style.background = 'transparent';

                            const left = document.createElement('div');
                            left.style.display = 'flex';
                            left.style.alignItems = 'center';
                            left.style.gap = '1rem';

                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.value = item.name;
                            checkbox.checked = !item.is_configured; // Default: check if unconfigured
                            checkbox.style.cssText = 'width: 16px; height: 16px; accent-color: var(--error-color);';
                            checkbox.onchange = updateCleanupCount;

                            const nameSpan = document.createElement('span');
                            nameSpan.textContent = item.name;
                            nameSpan.style.color = 'var(--text-primary)';
                            nameSpan.style.fontFamily = 'monospace';

                            const badge = document.createElement('span');
                            if (item.is_configured) {
                                badge.textContent = 'Configured';
                                badge.style.cssText = 'font-size: 0.7rem; background: rgba(34, 197, 94, 0.2); color: #4ade80; padding: 0.2rem 0.5rem; border-radius: 4px;';
                            } else {
                                badge.textContent = 'Unconfigured';
                                badge.style.cssText = 'font-size: 0.7rem; background: rgba(239, 68, 68, 0.2); color: #f87171; padding: 0.2rem 0.5rem; border-radius: 4px;';
                            }

                            left.appendChild(checkbox);
                            left.appendChild(nameSpan);
                            row.appendChild(left);
                            row.appendChild(badge);
                            listContainer.appendChild(row);
                        });
                    }

                    document.getElementById('cleanup-loading').style.display = 'none';
                    document.getElementById('cleanup-content').style.display = 'flex';
                    updateCleanupCount();
                } else {
                    document.getElementById('cleanup-loading').style.display = 'none';
                    document.getElementById('cleanup-error').textContent = result.message || 'Failed to load folders';
                    document.getElementById('cleanup-error').style.display = 'block';
                }
            } catch (err) {
                document.getElementById('cleanup-loading').style.display = 'none';
                document.getElementById('cleanup-error').textContent = 'Network error fetching folders';
                document.getElementById('cleanup-error').style.display = 'block';
            }
        }

        function updateCleanupCount() {
            const checked = document.querySelectorAll('#cleanup-list input[type="checkbox"]:checked').length;
            const countSpan = document.getElementById('cleanup-count');
            countSpan.textContent = checked > 0 ? `(${checked})` : '';
            document.getElementById('confirm-cleanup-btn').disabled = checked === 0;
            document.getElementById('confirm-cleanup-btn').style.opacity = checked === 0 ? '0.5' : '1';
        }

        async function execCleanup() {
            const checkboxes = document.querySelectorAll('#cleanup-list input[type="checkbox"]:checked');
            const folders = Array.from(checkboxes).map(cb => cb.value);

            if (folders.length === 0) return;

            const btn = document.getElementById('confirm-cleanup-btn');
            btn.innerHTML = '<span class="loading-spinner" style="display:inline-block; border-top-color:#fff; width:16px; height:16px;border-width:2px;margin-right:8px;"></span>Deleting...';
            btn.disabled = true;

            try {
                const response = await fetch('/api/cleanup', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folders })
                });
                const result = await response.json();

                btn.innerHTML = 'Delete Selected <span id="cleanup-count"></span>';
                btn.disabled = false;

                if (result.status === 'success' || result.status === 'partial_success') {
                    closeModal('cleanup-modal');
                    alert(`Successfully deleted ${result.deleted} folder(s). ${result.errors ? 'Errors: ' + result.errors.join(', ') : ''}`);
                } else {
                    alert('Error deleting folders: ' + result.message);
                }
            } catch (err) {
                btn.innerHTML = 'Delete Selected <span id="cleanup-count"></span>';
                btn.disabled = false;
                alert('Network error while deleting folders.');
            }
        }

        async function previewSyncAll() {
            const btn = document.getElementById('preview-sync-btn');
            btn.classList.add('btn-loading');
            try {
                const response = await fetch('/api/sync/preview_all', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const result = await response.json();

                if (result.status === 'success') {
                    const container = document.getElementById('preview-sync-results');
                    container.innerHTML = '';

                    if (result.results && result.results.length > 0) {
                        result.results.forEach(groupResult => {
                            const groupCard = document.createElement('div');
                            groupCard.style.cssText = 'background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border); border-radius: var(--radius-md); padding: 1rem;';

                            const header = document.createElement('div');
                            header.style.cssText = 'display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem; border-bottom: 1px solid var(--glass-border); padding-bottom: 0.5rem;';

                            const name = document.createElement('strong');
                            name.textContent = groupResult.group;
                            name.style.fontSize = '1.1rem';

                            const badge = document.createElement('span');
                            badge.textContent = `${groupResult.links} items`;
                            badge.style.cssText = 'background: var(--accent-color); color: #fff; padding: 0.3rem 0.6rem; border-radius: 12px; font-size: 0.75rem; font-weight: 600; white-space: nowrap;';

                            header.appendChild(name);
                            header.appendChild(badge);
                            groupCard.appendChild(header);

                            if (groupResult.error) {
                                const err = document.createElement('div');
                                err.style.cssText = 'color: var(--error-color); font-size: 0.85rem; margin-top: 0.5rem;';
                                err.textContent = `Error: ${groupResult.error}`;
                                groupCard.appendChild(err);
                            } else if (groupResult.items && groupResult.items.length > 0) {
                                const list = document.createElement('ul');
                                list.style.cssText = 'margin: 0; padding-left: 1.2rem; font-size: 0.85rem; color: var(--text-secondary); max-height: 150px; overflow-y: auto;';

                                groupResult.items.forEach((item) => {
                                    const li = document.createElement('li');
                                    li.textContent = item.Year ? `${item.Name} (${item.Year})` : item.Name;
                                    list.appendChild(li);
                                });

                                groupCard.appendChild(list);
                            } else {
                                const empty = document.createElement('div');
                                empty.style.cssText = 'color: var(--text-secondary); font-size: 0.85rem; font-style: italic;';
                                empty.textContent = 'No items found for this group.';
                                groupCard.appendChild(empty);
                            }

                            container.appendChild(groupCard);
                        });
                    } else {
                        container.innerHTML = '<div style="color: var(--text-secondary); font-style: italic; padding: 1rem;">No groupings configured.</div>';
                    }

                    document.getElementById('preview-sync-modal').style.display = 'flex';
                } else {
                    showStatus(result.message || 'Preview failed', 'error');
                }
            } catch (err) {
                showStatus('Preview failed - API unreachable', 'error');
            } finally {
                btn.classList.remove('btn-loading');
            }
        }

        async function syncAll() {
            const syncBtn = document.getElementById('sync-btn');
            syncBtn.classList.add('btn-loading');
            try {
                const response = await fetch('/api/sync', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const result = await response.json();
                if (result.status === 'success') {
                    let totalLinks = result.results.reduce((acc, r) => acc + r.links, 0);
                    showStatus(`Sync complete! Created ${totalLinks} symbolic links.`, 'success');
                } else {
                    showStatus(result.message || 'Sync failed', 'error');
                }
            } catch (err) {
                showStatus('Sync failed - API unreachable', 'error');
            } finally {
                syncBtn.classList.remove('btn-loading');
            }
        }

        // Initialize
        if (window.location.protocol === 'file:') {
            document.getElementById('connection-warning').style.display = 'block';
        } else {
            loadConfig();
        }
    </script>
</body>

</html>